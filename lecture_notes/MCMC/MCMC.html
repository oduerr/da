<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Oliver Dürr">

<title>Lecture Notes on MCMC</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="MCMC_files/libs/clipboard/clipboard.min.js"></script>
<script src="MCMC_files/libs/quarto-html/quarto.js"></script>
<script src="MCMC_files/libs/quarto-html/popper.min.js"></script>
<script src="MCMC_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="MCMC_files/libs/quarto-html/anchor.min.js"></script>
<link href="MCMC_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="MCMC_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="MCMC_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="MCMC_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="MCMC_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lecture Notes on MCMC</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Oliver Dürr </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<p>In this lecture note, we will discuss the basics of Markov Chain Monte Carlo (MCMC) methods. MCMC methods are a class of algorithms that are used to sample from a probability distribution <span class="math inline">\(p(\theta)\)</span> such as the posterior <span class="math inline">\(p(\theta|D)\)</span>. While there are more advanced MCMC methods, we will focus on the Metropolis-Hastings algorithm, which is a simple and widely used MCMC algorithm and shows the principles of MCMC methods.</p>
<section id="a-note-on-notation" class="level2">
<h2 class="anchored" data-anchor-id="a-note-on-notation">A note on notation</h2>
<p>In this lecture note, we will use the following notation:</p>
<ul>
<li><span class="math inline">\(\theta\)</span> is a parameter of interest. This could be a scalar or a vector.</li>
<li><span class="math inline">\(D\)</span> is the data.</li>
<li><span class="math inline">\(p(\theta)\)</span> is the prior distribution of <span class="math inline">\(\theta\)</span> and</li>
<li><span class="math inline">\(p(D|\theta)\)</span> is the likelihood of the data given <span class="math inline">\(\theta\)</span>.</li>
<li><span class="math inline">\(p(\theta|D)\)</span> is the posterior distribution of <span class="math inline">\(\theta\)</span> given the data.</li>
</ul>
<section id="using-ptheta-instead-of-pthetad" class="level3">
<h3 class="anchored" data-anchor-id="using-ptheta-instead-of-pthetad">Using <span class="math inline">\(p(\theta)\)</span> instead of <span class="math inline">\(p(\theta|D)\)</span></h3>
<p>Since the MCMC methods works with any probability distribution, we will use <span class="math inline">\(p(\theta)\)</span> to denote the target distribution that we want to sample from. In the context of Bayesian inference, <span class="math inline">\(p(\theta)\)</span> is the posterior distribution <span class="math inline">\(p(\theta|D)\)</span>, or, in the case of non date the prior distribution <span class="math inline">\(p(\theta)\)</span>.</p>
</section>
<section id="densities-vs.-probabilities" class="level3">
<h3 class="anchored" data-anchor-id="densities-vs.-probabilities">Densities vs.&nbsp;probabilities</h3>
<p>While in general in the lecture we will use the terms “density” and “probability” interchangeably. However, in the context of MCMC methods, we will use the term “density” to refer to the probability density function of a continuous distribution and “probability” to refer to the probability mass function of a discrete distribution. In case the destinction is crucial, we will use the terms <span class="math inline">\(Pr(\cdot)\)</span> for probabilities and <span class="math inline">\(p(\cdot)\)</span> for densities.</p>
</section>
</section>
<section id="a-high-level-overview-of-markov-chains." class="level2">
<h2 class="anchored" data-anchor-id="a-high-level-overview-of-markov-chains.">A high level overview of Markov Chains.</h2>
<p>A Markov chain is a sequence of random variables <span class="math inline">\(\theta_1, \theta_2, \theta_3, \ldots\)</span> which can be viewed as a time series where the next value depends only on the current value (Markov Property). In Figure <span class="citation" data-cites="fig:two-chains">@fig:two-chains</span>: we show two Markov chains, starting from different initial values. Note that after about 150 steps both chains fluctuate around the same value. This is the <em>stationary distribution</em> of the Markov chain.</p>
<div id="fig-two-chains" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><a href="https://github.com/oduerr/da/blob/master/lecture_notes/MCMC/SimpleMCMC.R"><img src="2chains.png" class="img-fluid figure-img"></a></p>
<figcaption class="figure-caption">Figure&nbsp;1: Shown are two Markov chains for the scalar quantity $\theta$. The chains start from different initial positions. After about 150 time steps the chains fluctate around the same value.</figcaption>
</figure>
</div>
<p>In Figure <span class="citation" data-cites="fig:two-chain-dist">@fig:two-chain-dist</span>, we show a histogram of the values of the two chains after from 250 steps onward. The histogram indicate that the values of the chains are distributed around the same distribution is the stationary distribution of the Markov chain.</p>
<div id="two-chain-dist" data-fig-align="center">
<p><a href="https://github.com/oduerr/da/blob/master/lecture_notes/MCMC/SimpleMCMC.R"><img src="2chains-marginal.png" class="img-fluid"></a></p>
<p>The Histogram (actually density estimates) for of the two chains after 250 steps</p>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>The key idea of MCMC methods is to construct a Markov chain that has a stationary distribution equal to the target distribution <span class="math inline">\(p(\theta)\)</span>. Once the Markov chain has converged to the stationary distribution, we can use the samples from the chain to approximate the target distribution.</p>
</div>
</div>
<p>So how do we construct a Markov chain with a stationary distribution equal to the target distribution <span class="math inline">\(p(\theta)\)</span>? To do so, we draw insights from statistical physics.</p>
<section id="statistical-physics-and-detailed-balance" class="level3">
<h3 class="anchored" data-anchor-id="statistical-physics-and-detailed-balance">Statistical physics and detailed balance</h3>
<p>Consider a glass of water in which we add a drop of ink. The ink will spread out in the water until it is uniformly distributed. This is an example of a system that has reached equilibrium. Nearly every statistical system reaches the equilibrium state. Exceptions are periodic systems like a pendulum or a planet orbiting a star and systems that get trapped in a local minimum.</p>
</section>
</section>
<section id="detailed-balance" class="level2">
<h2 class="anchored" data-anchor-id="detailed-balance">Detailed balance</h2>
<p>For a Markov chain to be useful, it needs to convert of a stationary distribution and the stationary distribution needs to be the target distribution <span class="math inline">\(p(\theta)\)</span>. The Metropolis-Hastings algorithm is a simple MCMC algorithm that ensures that the Markov chain converges to the desired stationary distribution. The Metropolis-Hastings algorithm is based on the principle of detailed balance. Also almost all other MCMC algorithms (such as Hamiltonian Monte Carlo, Slice Sampling, and Gibbs Sampling) are based on the principle of detailed balance. So what is detailed balance?</p>
<p>Remember the example with the king visiting the islands? The king will visit the islands with a probability proportional to the number of people on the island. This was an example of detailed balance. Now consider N Kings, in order that the number of Kings on the islands have reached a stationary distribution, at each time step as many Kings need to move from one island to another as move in the opposite direction. This is the principle of detailed balance and if it is fullfilled the Markov chain has converge to the stationary distribution. The detailed balance condition is (a bit slopy) given by:</p>
<p><span class="math display">\[
  P_{ij} N_j = P_{ji} N_i
\]</span></p>
<p>with <span class="math inline">\(P_{ij}\)</span> the probability of moving from island <span class="math inline">\(i\)</span> to island <span class="math inline">\(j\)</span> and <span class="math inline">\(N_i\)</span> the number of Kings on island <span class="math inline">\(i\)</span>. Let’s divide both sides by <span class="math inline">\(N\)</span></p>
<p><span class="math display">\[
P_{ij}\underbrace{P_{j}}_{N_j/N} = P_{ji}\underbrace{P_{i}}_{N_j/N}
\]</span></p>
<p>Figure @ shows the detailed balance situation in a system with discrete states. Note that the detailed balence is between two states <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> and that other states <span class="math inline">\(k\)</span> are not taken into account.</p>
<div id="db" data-fig-align="center">
<p><a href="https://github.com/oduerr/da/blob/master/lecture_notes/MCMC/img_sources"><img src="img_sources/db.png" class="img-fluid"></a></p>
<p>Illustration of the detailed balance condition in a Markov chain. The transition probabilities $P_{ij}$ and $P_{ji}$ between states $j$ and $i$ are shown, along with their respective stationary probabilities $P_i$ and $P_j$. The light gray dashed arrows indicate the presence of other states in the Markov chain, emphasizing that the detailed balance condition is specifically applied between states $i$ and $j$</p>
</div>
<p>It’s quite illustrative a system with many particles. The detailed balance condition the probability <span class="math inline">\(P_{ij}P_j\)</span> (fraction of Kings/Particle) move from <span class="math inline">\(j\)</span> to <span class="math inline">\(i\)</span> is equal to the probability <span class="math inline">\(P_{ji}P_i\)</span> (fraction of Kings/Particle) move from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>.</p>
<section id="controling-p_ij" class="level3">
<h3 class="anchored" data-anchor-id="controling-p_ij">Controling <span class="math inline">\(P_{ij}\)</span></h3>
<p>Let’s choose <span class="math inline">\(P_{ij}\)</span> in our favor, so that in equilibrium the distribution <span class="math inline">\(P_i\)</span> is the distribution we want. We can do this by proposing a move from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span> with a probability <span class="math inline">\(T_{ij}\)</span> and then accept the move with an acceptance probability <span class="math inline">\(A_{ij}\)</span>. The cool idea that physicists had in the 1950’s is to choose the acceptence probability <span class="math inline">\(A_{ij}\)</span> as:</p>
<section id="metropolis-hastings-acceptance-probability" class="level4">
<h4 class="anchored" data-anchor-id="metropolis-hastings-acceptance-probability">Metropolis-Hastings acceptance probability</h4>
<p><span class="math display">\[
A_{ij} = \min (1, \frac{T_{ji}P_i}{T_{ij} P_j})
\]</span></p>
<p>Why is detailed balance fullfilled?</p>
<p><img src="images/db.png" class="img-fluid" width="504"></p>
<p>If we know move a particle according to the Metropolis Hastings Acceptance rate. We start in state <span class="math inline">\(\theta_0\)</span> and propose a move to <span class="math inline">\(\theta^*\)</span> with <span class="math inline">\(T(\theta^*|\theta_0)\)</span>. We accept the new state with a probability according to the MH Acceptance probability. If we repeat we get the following chain of moves.</p>
<ol type="1">
<li><strong>Initialize</strong>: Start with an initial value <span class="math inline">\(\theta_0\)</span>.</li>
<li><strong>Propose</strong>: Generate a candidate <span class="math inline">\(\theta^*\)</span> from a proposal distribution <span class="math inline">\(T(\theta^* | \theta_t)\)</span>.</li>
<li><strong>Calculate Acceptance Probability</strong>: Compute the acceptance probability <span class="math display">\[
A_{ij} = \min \left(1, \frac{T(\theta_t | \theta^*) p(\theta^*)}{T(\theta^* | \theta_t) p(\theta_t)}\right)
\]</span></li>
<li><strong>Accept</strong>: With probability <span class="math inline">\(A_{ij}\)</span>, set <span class="math inline">\(\theta_{t+1} = \theta^*\)</span>. Otherwise, set <span class="math inline">\(\theta_{t+1} = \theta_t\)</span>.</li>
<li><strong>Iterate</strong>: Repeat steps 2-4 for a large number of iterations to ensure convergence to the stationary distribution.</li>
</ol>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>For the acceptance rate <span class="math inline">\(p(\theta)\)</span> is needed only up to a constant factor, this makes it ideal for Bayesian inference, where we just need <span class="math inline">\(p(\theta|D) \propto p(D|\theta)p(\theta)\)</span>.</p>
</div>
</div>
<p>This process ensures that the Markov chain will converge to the target distribution <span class="math inline">\(p(\theta)\)</span>, allowing us to approximate the distribution through the samples obtained from the chain. Let’s give it a try, we assume symetric proposal distribution <span class="math inline">\(T(\theta^*|\theta) = T(\theta|\theta^*)\)</span> and we want to sample from the <span class="math inline">\(p(\theta) \ propto x^2\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial values</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>Steps <span class="ot">=</span> <span class="dv">10000</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>plot_max <span class="ot">=</span> <span class="dv">500</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>thetas <span class="ot">=</span> <span class="fu">rep</span>(<span class="cn">NA</span>, Steps)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Some target distribution (only up to a constant factor)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> <span class="cf">function</span>(theta){</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="fu">dexp</span>(theta, <span class="at">rate=</span><span class="dv">1</span><span class="sc">/</span><span class="dv">10</span>)<span class="sc">*</span><span class="dv">42</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>theta <span class="ot">=</span> <span class="dv">60</span> <span class="co">#Initial value</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (t <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>Steps) {</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  theta_star <span class="ot">=</span> <span class="fu">rnorm</span>(<span class="dv">1</span>, theta, <span class="dv">15</span>)  <span class="co"># Propose a new value</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  A <span class="ot">=</span> <span class="fu">min</span>(<span class="dv">1</span>, <span class="fu">p</span>(theta_star)<span class="sc">/</span><span class="fu">p</span>(theta)) <span class="co">#Acceptance probability</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Accept or reject the new value</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">runif</span>(<span class="dv">1</span>) <span class="sc">&lt;</span> A) { <span class="co"># Accept (typical trick)</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    thetas[t] <span class="ot">=</span> theta_star</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    theta <span class="ot">=</span> theta_star </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  } </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  thetas[t] <span class="ot">=</span> theta</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="dv">1</span><span class="sc">:</span>plot_max, thetas[<span class="dv">1</span><span class="sc">:</span>plot_max], <span class="at">type =</span> <span class="st">"l"</span>, <span class="at">xlab =</span> <span class="st">"Steps"</span>, <span class="at">ylab =</span> <span class="st">"Theta"</span>, <span class="at">main=</span><span class="st">"Trace of the samples"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="MCMC_files/figure-html/simple-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(thetas[<span class="dv">200</span><span class="sc">:</span>Steps], <span class="at">main =</span> <span class="st">"Density of the samples"</span>, <span class="at">freq=</span><span class="cn">FALSE</span>, <span class="dv">30</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="MCMC_files/figure-html/simple-2.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>