[
  {
    "objectID": "Stan_Primer_Full.html",
    "href": "Stan_Primer_Full.html",
    "title": "Stan primer",
    "section": "",
    "text": "MCMC with Stan / Simple diagnostics"
  },
  {
    "objectID": "Stan_Primer_Full.html#cmdstan",
    "href": "Stan_Primer_Full.html#cmdstan",
    "title": "Stan primer",
    "section": "Cmdstan",
    "text": "Cmdstan\n\nlibrary(cmdstanr)\noptions(mc.cores = parallel::detectCores()) #Make it faster\nm_rcmdstan &lt;- cmdstan_model(file_stan) #Compiling\ns_rcmdstan = m_rcmdstan$sample(data = data) #Sampling\ndf = s_rcmdstan$draws(format = \"df\") #Extracting Samples as data.frame"
  },
  {
    "objectID": "Stan_Primer_Full.html#tidy-bayes",
    "href": "Stan_Primer_Full.html#tidy-bayes",
    "title": "Stan primer",
    "section": "Tidy Bayes",
    "text": "Tidy Bayes\nWorks with rstan and cmdstanr\n\nlibrary(tidybayes)\nspread_draws(s, c(a,b)) #Extracts a and b from s (stan or cmdstan samples)\nspread_draws(s, f[i])  #Extracts vector f and calls components i"
  },
  {
    "objectID": "Stan_Primer_Full.html#bayes-plot",
    "href": "Stan_Primer_Full.html#bayes-plot",
    "title": "Stan primer",
    "section": "Bayes plot",
    "text": "Bayes plot\nWorks with rstan and cmdstanr\n\n  s = s_rcmdstan$draws() #We need to call draws() 2023\n  bayesplot::mcmc_trace(s)"
  },
  {
    "objectID": "Stan_Primer_Full.html#rendering-quarto-for-exercises",
    "href": "Stan_Primer_Full.html#rendering-quarto-for-exercises",
    "title": "Stan primer",
    "section": "Rendering Quarto for exercises",
    "text": "Rendering Quarto for exercises\nPrinting the model in markdown files (only important for rendering exercise sheets), see e.g. around here\n{r, echo=lsg, eval=FALSE, code=readLines(“../world.stan”), collapse=TRUE}\nNot showing the many details in MCMC simulation with Stan. | ```{r, echo=lsg, eval=lsg, message=FALSE, warning=FALSE, results=“hide”}"
  },
  {
    "objectID": "Stan_Primer_Full.html#stan",
    "href": "Stan_Primer_Full.html#stan",
    "title": "Stan primer",
    "section": "Stan",
    "text": "Stan\n\nlibrary(rstan)\noptions(mc.cores = parallel::detectCores())\nrstan_options(javascript=FALSE) #Prevents freezes of RStudio (Jan 2023) \n\nm_rstan = stan_model(model_code = stan_code) #Compiling from string\nm_rstan = stan_model(file='mymodel.stan') #Compiling from file\ns_rstan = sampling(m_rstan, data=data) #Sampling from file\n\n#No MCMC just evaluating parameters\nsampling(model_1, data=dat, algorithm=\"Fixed_param\", chain=1, iter=1)"
  },
  {
    "objectID": "Stan_Primer_Full.html#other-cheat-sheets",
    "href": "Stan_Primer_Full.html#other-cheat-sheets",
    "title": "Stan primer",
    "section": "Other Cheat Sheets",
    "text": "Other Cheat Sheets\n\nhttp://www.sumsar.net/files/posts/2017-bayesian-tutorial-exercises/stan_cheat_sheet2.12.pdf\nhttps://github.com/sieste/Stan_cheatsheet"
  },
  {
    "objectID": "Stan_Primer_Full.html#data-used",
    "href": "Stan_Primer_Full.html#data-used",
    "title": "Stan primer",
    "section": "Data used",
    "text": "Data used\nSome Data for linear regression\n\nN = 4\nx = c(-2.,-0.66666, 0.666, 2.)\ny = c(-6.25027354, -2.50213382, -6.07525495,  7.92081243)\ndata = list(N=N, x=x, y=y)"
  },
  {
    "objectID": "Stan_Primer_Full.html#getting-samples-from-the-posterior",
    "href": "Stan_Primer_Full.html#getting-samples-from-the-posterior",
    "title": "Stan primer",
    "section": "Getting samples from the posterior",
    "text": "Getting samples from the posterior\nThere are currently (2023) two interfaces to stan from R. RStan (https://mc-stan.org/users/interfaces/rstan) which is a bit slower and does not use the latest stan compiler and rcmdstan (https://mc-stan.org/cmdstanr/articles/cmdstanr.html).\n\nThe technical steps\nThere are 3 steps:\n\nDefining the model\nCompiling the model. In this step C code is generated.\nRunning the simulation / sampling from the posterior\nExtracting the samples from the posterior\n\n\n\nDefinition\nTo define a model, you can add a string or create a .stan file. Another option is to use a Stan markdown chunk and output.var=my_model to the name of the model. Code completion and highlighting is working for files and code chunks.\n\nstan_code = \"data{\n  int&lt;lower=0&gt; N; \n  vector[N] y;\n  vector[N] x;\n}\n\nparameters{\n  real a; //Instead of using e.g. half Gaussian\n  real b;\n  real&lt;lower=0&gt; sigma;\n}\n\nmodel{\n  //y ~ normal(mu, sigma);\n  y ~ normal(a * x + b, sigma);\n  a ~ normal(3, 10); \n  b ~ normal(0, 10); \n  sigma ~ normal(0,10);\n}\"\n\n\n\nCompiling\nCompiling works with:\n\nCompiling rstan stan_model(model_code = stan_code) or stan_model(file='mymodel.stan')\nCompiling cmdstan cmdstan_model(file_stan)\n\n\nCompiling with rstan\n\n  library(rstan)\n  m_rstan = stan_model(model_code = stan_code)\n\n\n\nCompiling with rcmdstan\nThere is no possibility to use a string for cmd_stan.\n\n  m_rcmdstan &lt;- cmdstan_model(stan_file='stan/simple_lr.stan')\n  m_rcmdstan$print() #Displays the used model\n\n\n\n\nSampling / running the chains\nFor rstan: sampling(m_rstan, data=data) For cmdstan: mod$sample(data = data_file, seed=123)\n\n  s_rcmdstan = m_rcmdstan$sample(data = data)\n\n\n  s_rstan = sampling(m_rstan)  \n\n\n\nDiagnostics of the chains\nThe package bayesplot can handle both interfaces\n\nTrace\n\n#traceplot(s_rstan, 'a')\n#bayesplot::mcmc_trace(s_rstan)\nbayesplot::mcmc_trace(s_rcmdstan$draws()) #similar result\ns_rstan\n# Rhat close to one and n_eff lager than half the number of draws; look fine\n\nKey Numbers\n\nRhat is something like the ratio of variation between the chains to withing the chains\nn_eff number of effective samples taking the autocorrelation into account (in cmd_stan the output is ess_bulk and ess_tail)\n\n\n\nShiny Stan\n\n  #Shiny Stan, quite overwhelming\n  library(shinystan)\n  launch_shinystan(s_rcmdstan)\n  \n  #If not working\n  #See https://discourse.mc-stan.org/t/will-launch-shinystan-work-soon-for-cmdstanr/17269\n  stanfit = rstan::read_stan_csv(s_rcmdstan$output_files())\n  launch_shinystan(stanfit)\n\n\n\n\nPosteriors (of the parameters)\nGetting the samples can be done as\n\nRstan extract(s_rstan)\ncmdstan s_rcmdstan$draws()\n\nAnother handy package is tidybayes which can handle the output of rstan and rcmdstan\n\nTidybayes\n\nlibrary(tidybayes)\nhead(spread_draws(s_rcmdstan, c(a,b))) #Non-tidy a and b in one row\n\n# A tibble: 6 × 5\n  .chain .iteration .draw     a      b\n   &lt;int&gt;      &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1      1          1     1 1.99  -1.76 \n2      1          2     2 3.04   2.89 \n3      1          3     3 4.95  -3.39 \n4      1          4     4 0.934 -2.30 \n5      1          5     5 2.36   0.303\n6      1          6     6 5.31  -2.45 \n\nhead(gather_draws(s_rcmdstan, c(a,b))) #The ggplot like syntax\n\n# A tibble: 6 × 5\n# Groups:   .variable [1]\n  .chain .iteration .draw .variable .value\n   &lt;int&gt;      &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;dbl&gt;\n1      1          1     1 a          1.99 \n2      1          2     2 a          3.04 \n3      1          3     3 a          4.95 \n4      1          4     4 a          0.934\n5      1          5     5 a          2.36 \n6      1          6     6 a          5.31 \n\n#spread_draws(model_weight_sex, a[sex]) for multilevel models\n\n\n\nCommand Stan Functions\nFor more see: https://mc-stan.org/cmdstanr/articles/cmdstanr.html\n\ndf &lt;- s_rcmdstan$draws(format = \"df\")\ndf %&gt;% select(-c(.chain, .iteration, .draw)) %&gt;% cor()\n\nWarning: Dropping 'draws_df' class as required metadata was removed.\n\n\n            lp__           a           b      sigma\nlp__   1.0000000  0.12991773 -0.10625738 -0.6907346\na      0.1299177  1.00000000 -0.03857131 -0.1040964\nb     -0.1062574 -0.03857131  1.00000000  0.1078610\nsigma -0.6907346 -0.10409641  0.10786104  1.0000000\n\n\n\n\nStan functions\n\n  #plot(samples)\n  #samples = extract(s_rstan)\n  stan_dens(s_rstan)\n\n\n\n\n\n\n\n  #Note that these are marginals!\n\n\n\n“Manually” visualize the posterior\nWe extract samples from the posterior via extract (in some installation the wrong extract function is taken in that case use rstan::extract to use the right one). Visualize the posterior distribution of \\(a\\) from the samples.\n\n# Extract samples\npost = rstan::extract(s_rstan)\nT = length(post$a)\nhist(post$a,100, freq=F)\nlines(density(post$a),col='red')  \n\n\n\n\n\n\n\n\n\n\nPairs plot\nUsing the pairs plot, correlations in the variables can be found.\n\nnp_cp = bayesplot::nuts_params(s_rstan)\nbayesplot::mcmc_pairs(s_rstan, np = np_cp,pars = c(\"a\",\"b\"))\n\n\n\n\n\n\n\n\n\n\n\nPosterior Predictive Plots\n\n\nTask: Use the samples to create the following posterior predictive plots\nSome background first: posterior predictive distribution: \\[\n  p(y|x, D) =  \\int p(y|x,\\theta) p(\\theta|D) \\; d\\theta\n\\] Instead of integration, we sample in two turns\n\n\\(\\theta_i \\sim p(\\theta|D)\\)\n\\(y_{ix} \\sim p(y|x,\\theta_i)\\) #We do this for many x in practice\n\n\nCreation of the posterior predictive samples by hand\nYou can either do this part, or use stan to create the posterior predictive samples \\(y_{ix}\\) from the samples \\(\\theta_i\\) by hand.\nTip: Create two matrices yix and muix from the posterior samples of \\(a,b,\\sigma\\) with dimension (rows = number of posterior samples and cols = number of x positions).\n\nxs = -10:15 # The x-range 17 values from -1 to 15\nM = length(xs) \nyix = matrix(nrow=T, ncol = M) #Matrix from samples (number of posterior draws vs number of xs)\nmuix = matrix(nrow=T, ncol = M) #Matrix from mu (number of posterior draws vs number of xs)\nfor (i in 1:T){ #Samples from the posterior\n  a = post$a[i] #Corresponds to samples from theta\n  b = post$b[i]\n  sigma = post$sigma[i]\n  for (j in 1:M){ #Different values of X\n    mu = a * xs[j] + b\n    muix[i,j] = a * xs[j] + b\n    yix[i,j] = rnorm(1, mu, sigma) # Single number drawn\n  }\n}\n\nif (FALSE){\n  plot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='mu=a*x+b')\n  for (i in 1:100){\n    lines(xs, muix[i,],lwd=0.25,col='blue')\n  }\n  \n  plot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='ys')\n  for (i in 1:100){\n    points(xs, yix[i,], pch='.',col='red')\n  }\n}\n\nAfter you created the matrices yix and muix you can use the following function to draw the lines for the quantiles.\n\nplot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='quantiles (y and mu)')\nquant_lines = function(x2, y_pred, col='blue'){\n  m = apply(y_pred, 2,quantile, probs=c(0.50))\n  lines(x2, m,col=col)\n  q05 = apply(y_pred, 2, quantile, probs=c(0.25))\n  q95 = apply(y_pred, 2, quantile, probs=c(0.75))\n  lines(x2, q05,col=col)\n  lines(x2, q95,col=col)  \n}\n\nquant_lines(xs,yix, col='red')\nquant_lines(xs,muix, col='blue')\n\n\n\n\n\n\n\n\n\n\nCreation of the posterior predictive samples with Stan\nIt’s also possible to draw posterior predictive samples. One can use the generated quantities code block for that.\ndata{\n  int&lt;lower=0&gt; N;\n  vector[N] y;\n  vector[N] x;\n  //For the prediced distribution (new)\n  int&lt;lower=0&gt; N2;\n  vector[N2] x2;\n}\n\ngenerated quantities {\n  real Y_predict[N2]; \n  for (i in 1:N2){\n    Y_predict = normal_rng(a * x2 + b, sigma);\n  }\n}\n\n  x2 = -10:15\n  N2 = length(x2)\n  fit2 = rstan::stan(file = '~/Dropbox/__HTWG/DataAnalytics/_Current/lab/06_03_Bayes_3/Stan_Primer_model_pred.stan',\n                         data=list(N=N,x=x, y=y, N2=N2,x2=x2),iter=10000)\n\n\n  d2 = rstan::extract(fit2)\n  y_pred = d2$Y_predict\n  dim(y_pred)\n  plot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='quantiles (y and mu)')\n  quant_lines(x2,y_pred, col='red')\n\n\n\n\nNotes on creating excercises\n\nInclusion of Stan code\nIn case of cmdrstan the Stan code should be in an extra file to make the workflow easier and reuse compiled models. In case of rstan the Stan code can be included in the Rmd file as:\n{r, echo=TRUE, eval=FALSE, code=readLines(“../world.stan”), collapse=TRUE, echo=TRUE}"
  },
  {
    "objectID": "Stan_Primer_Full.html#rstudio-bug-2023",
    "href": "Stan_Primer_Full.html#rstudio-bug-2023",
    "title": "Stan primer",
    "section": "RStudio bug 2023",
    "text": "RStudio bug 2023\nSometimes R gets slow when rendering with stan code. At least in my case\nrstan_options(javascript=FALSE)\nNot observed anymore (2024)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "da_website",
    "section": "",
    "text": "This is a collection of bits and pieces useful in connection with data analysis."
  },
  {
    "objectID": "lecture_notes/MCMC/MCMC.html",
    "href": "lecture_notes/MCMC/MCMC.html",
    "title": "Lecture Notes on MCMC",
    "section": "",
    "text": "In this lecture note, we will discuss the basics of Markov Chain Monte Carlo (MCMC) methods. MCMC methods are a class of algorithms that are used to sample from a probability distribution \\(p(\\theta)\\) such as the posterior \\(p(\\theta|D) \\propto p(D|\\theta) p(\\theta)\\). While there are more advanced MCMC methods, we will focus on the Metropolis-Hastings algorithm, which is a simple and widely used MCMC algorithm and shows the principles of MCMC methods."
  },
  {
    "objectID": "lecture_notes/MCMC/MCMC.html#a-note-on-notation",
    "href": "lecture_notes/MCMC/MCMC.html#a-note-on-notation",
    "title": "Lecture Notes on MCMC",
    "section": "📝 A note on notation",
    "text": "📝 A note on notation\nIn this lecture note, we will use the following notation:\n\n\\(\\theta\\) is a parameter of interest. This could be a scalar or a vector.\n\\(D\\) is the data.\n\\(p(\\theta)\\) is the prior distribution of \\(\\theta\\) and\n\\(p(D|\\theta)\\) is the likelihood of the data given \\(\\theta\\).\n\\(p(\\theta|D)\\) is the posterior distribution of \\(\\theta\\) given the data \\(D\\)\n\nAll expressions are read right to left, e.g. \\(p(\\theta|D)\\) is the posterior distribution of \\(\\theta\\) given the data \\(D\\) and \\(P_{ij}\\) is the probability of moving from state \\(j\\) to state \\(i\\).\n\nUsing \\(p(\\theta)\\) instead of \\(p(\\theta|D)\\)\nSince the MCMC methods works with any probability distribution, we will use \\(p(\\theta)\\) to denote the target distribution that we want to sample from. In the context of Bayesian inference, \\(p(\\theta)\\) is the posterior distribution \\(p(\\theta|D)\\) without explicitly stating the data \\(D\\). You can also think of it as the posterior when you have no data (the prior).\n\n\n📊 Densities vs. 📉 probabilities\nWhile in general in the lecture we will use the terms “density” and “probability” interchangeably. However, in the context of MCMC methods, we will use the term “density” to refer to the probability density function of a continuous distribution and “probability” to refer to the probability mass function of a discrete distribution. In case the destinction is crucial, we will use the terms \\(P(\\cdot)\\) for probabilities and \\(p(\\cdot)\\) for densities."
  },
  {
    "objectID": "lecture_notes/MCMC/MCMC.html#a-high-level-overview-of-markov-chains.",
    "href": "lecture_notes/MCMC/MCMC.html#a-high-level-overview-of-markov-chains.",
    "title": "Lecture Notes on MCMC",
    "section": "🔭 A high level overview of Markov Chains.",
    "text": "🔭 A high level overview of Markov Chains.\nA Markov chain is a sequence of random variables \\(\\theta_1, \\theta_2, \\theta_3, \\ldots\\) which can be viewed as a time series where the next value depends only on the current value (Markov Property). In Figure 1: we show two Markov chains, starting from different initial values. Note that after about 150 steps both chains fluctuate around the same value. This is the stationary distribution of the Markov chain. A Markov chain reaches a stationary distribution when the distribution of the states no longer changes as the chain progresses.\n\n\n\n\n\n\nFigure 1: Shown are two Markov chains for the scalar quantity $\\theta$. The chains start from different initial positions. After about 150 time steps the chains fluctate around the same value.\n\n\n\nIn Figure 2, we show a histogram1 of the values of the two chains after from 250 steps onward. The histogram indicate that the values of the chains are distributed around the same distribution is the stationary distribution of the Markov chain.\n\n\n\n\n\n\nFigure 2: The Histogram (actually density estimates) for of the two chains after 250 steps\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe key idea of MCMC methods is to construct a Markov chain that has a stationary distribution equal to the target distribution \\(p(\\theta)\\). Once the Markov chain has converged to the stationary distribution, we can use the samples from the chain to approximate the target distribution.\n\n\nSo how do we construct a Markov chain with a stationary distribution equal to the target distribution \\(p(\\theta)\\)? To do so, we draw insights from statistical physics.\n\nStatistical physics and detailed balance\nConsider a glass of water in which we add a drop of ink. The ink will spread out in the water until it is uniformly distributed. This is an example of a system that has reached equilibrium. The the following ideas, are important inspirations for MCMC methods:\nErgodic Hypothesis - The diffusion process can be viewed as either a single particle or many particles. Initially concentrated in one region, a particle will eventually explore the entire space uniformly, regardless of its starting point. This idea, known as the Ergodic Hypothesis, was first proposed by Boltzmann.\nThe reaching of the stationary distribution - Over time, particles reach a stationary distribution (in physics is referred to as the equilibrium distribution). For example, ink in water eventually reaches a uniform distribution. However, not all distributions are uniform. For instance, the barometric height equation describes how particles in the air are more concentrated at the ground and decrease exponentially with height.\nDetailed Balance - At stationarity, the rate at which particles move from one point to another is equal to the rate at which they move in the opposite direction. This concept is known as detailed balance and is crucial for understanding the Metropolis-Hastings algorithm.\nFrom that, we can design the MCMC Algorithms algorithms. Roughly as follows * Start with parameter of interest \\(\\theta\\) at certain position * Mimics the diffusion process but with a stationary distribution of our choosing \\(p(\\theta)\\) * Algorithm needs to obey the detailed balance condition, this allow us to define the transition probabiliy with which we go from one value to another."
  },
  {
    "objectID": "lecture_notes/MCMC/MCMC.html#detailed-balance",
    "href": "lecture_notes/MCMC/MCMC.html#detailed-balance",
    "title": "Lecture Notes on MCMC",
    "section": "⚖️ Detailed balance",
    "text": "⚖️ Detailed balance\nFor a Markov chain to be useful, it needs to convert to a stationary distribution and the stationary distribution needs to be the target distribution \\(p(\\theta)\\). The Metropolis-Hastings algorithm is a simple MCMC algorithm that ensures that the Markov chain converges to the desired stationary distribution. The Metropolis-Hastings algorithm is based on the principle of detailed balance. Also almost all other MCMC algorithms (such as Hamiltonian Monte Carlo, Slice Sampling, and Gibbs Sampling) are based on the principle of detailed balance. So what is detailed balance?\nFor the ink particles, we have a uniforn distribution as stationary distribution. For the ink particles in the water glass the detailed balance condition is that the rate at which particles move from one point to another is equal to the rate at which they move in the opposite direction. Remember the example with the king visiting the islands? The king will visit the islands with a probability proportional to the size on the island. So the stationary distribution is not uniform anymore. The detailed balance condition can be used to determine the probability \\(P_{ji}\\) of moving from island \\(i\\) to island \\(j\\). Now consider N Kings, in order that the number of Kings on the islands have reached a stationary distribution, at each time step as many Kings need to move from one island to another as move in the opposite direction. Otherwise the number of Kings on the islands would change over time and we have not yet reached the stationary distribution. The detailed balance condition is (a bit slopy) given by:\n\\[\n  P_{ij} N_j = P_{ji} N_i\n\\]\nwith \\(P_{ij}\\) the probability of moving from island \\(i\\) to island \\(j\\) and \\(N_i\\) the number of Kings on island \\(i\\). Let’s divide both sides by \\(N\\)\n\\[\nP_{ij}\\underbrace{P_{j}}_{N_j/N} = P_{ji}\\underbrace{P_{i}}_{N_j/N}\n\\]\nFigure 3 shows the detailed balance situation in a system with discrete states (such as kings). Note that the detailed balence is between two states \\(i\\) and \\(j\\) and that other states \\(k\\) are not taken into account.\n\n\n\n\n\n\nFigure 3: Illustration of the detailed balance condition in a Markov chain. The transition probabilities $P_{ij}$ and $P_{ji}$ between states $j$ and $i$ are shown, along with their respective stationary probabilities $P_i$ and $P_j$. The light gray dashed arrows indicate the presence of other states in the Markov chain, emphasizing that the detailed balance condition is specifically applied between states $i$ and $j$\n\n\n\nThe detailed balance condition the probability \\(P_{ij}P_j\\) (fraction of Kings/Particle) move from \\(j\\) to \\(i\\) is equal to the probability \\(P_{ji}P_i\\) (fraction of Kings/Particle) move from \\(i\\) to \\(j\\).\n\n🎛️Controling \\(P_{ij}\\)\nLet’s choose \\(P_{ij}\\) in our favor, so that in equilibrium the distribution \\(P_i\\) is the distribution we want. We can do this by proposing a move from \\(i\\) to \\(j\\) with a probability \\(T_{ij}\\) and then accept the move with an acceptance probability \\(A_{ij}\\). The cool idea that physicists had in the 1950’s is to choose the acceptence probability \\(A_{ij}\\) as:\n\nMetropolis-Hastings acceptance probability\n\\[\nA_{ij} = \\min (1, \\frac{T_{ji}P_i}{T_{ij} P_j})\n\\]\nWhy is detailed balance fullfilled?\n\nIf we know move a particle according to the Metropolis Hastings Acceptance rate. We start in state \\(\\theta_0\\) and propose a move to \\(\\theta^*\\) with \\(T(\\theta^*|\\theta_0)\\). We accept the new state with a probability according to the MH Acceptance probability. If we repeat we get the following chain of moves.\n\nInitialize: Start with an initial value \\(\\theta_0\\).\nPropose: new state \\(\\theta^*\\) from old state \\(\\theta_t\\) with a proposal distribution \\(T(\\theta^* | \\theta_t)\\).\nCalculate Acceptance Probability: Compute the acceptance probability \\[\n  A  = \\min \\left(1, \\frac{T(\\theta_t | \\theta^*) p(\\theta^*)}{T(\\theta^* | \\theta_t) p(\\theta_t)}\\right)\n\\]\nAccept proposed state: With probability \\(A\\), set \\(\\theta_{t+1} = \\theta^*\\). Otherwise, continue with old state, \\(\\theta_{t+1} = \\theta_t\\).\nIterate: Repeat steps 2-4 for a large number of iterations to ensure convergence to the stationary distribution.\n\n\n\nA short note on the continuous case\nSo far we have discussed the Metropolis-Hastings algorithm in the context of discrete states. However, the Metropolis-Hastings algorithm can be extended to continuous states, easily. There might be pitfalls when changing to the continuous case, don’t just replace the probabilities \\(P_i\\) with densities \\(p(\\theta)\\)! However here the Metropolis-Hastings algorithm is the same as in the discrete case. Just exchange the probabilities with densities.\n\n\n\n\n\n\nNote\n\n\n\nFor the acceptance rate \\(p(\\theta)\\) is needed only up to a constant factor, this makes it ideal for Bayesian inference, where we just need \\(p(\\theta|D) \\propto p(D|\\theta)p(\\theta)\\).\n\n\nThis process ensures that the Markov chain will converge to the target distribution \\(p(\\theta)\\), allowing us to approximate the distribution through the samples obtained from the chain. Let’s give it a try, we assume symetric proposal distribution \\(T(\\theta^*|\\theta) = T(\\theta|\\theta^*)\\) and we want to sample from the \\(p(\\theta) \\propto Exp(\\lambda = 1/10)\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n📝 Exercise (Simple MCMC Algorithm)\n\n\n\n\n\n\n📝 Exercise (Simple MCMC Algorithm)\n\n\n\nPlay around with the code above.\n\nWhat do you observe if you change the standard deviation of the proposal distribution?\nChange the target distribution to \\(p(\\theta) \\propto \\exp(-\\theta^2/2)\\)."
  },
  {
    "objectID": "lecture_notes/MCMC/MCMC.html#the-hairy-caterpillar",
    "href": "lecture_notes/MCMC/MCMC.html#the-hairy-caterpillar",
    "title": "Lecture Notes on MCMC",
    "section": "🐛The hairy caterpillar",
    "text": "🐛The hairy caterpillar\nThere can be several problems when using the Metropolis-Hastings algorithm.\n\nSlow mixing: The Markov chain takes a long time to converge to the stationary distribution.\nRandom walk behavior: Too small steps in the proposal distribution can lead to a behavior, where the chain moves slowly through the parameter space and many samples are correlated.\nTrap in local minima: The chain gets trapped in a local minimum and does not explore the parameter space properly\n\n\n🛠️ Tools to inspect the chain\nFirst look at the trace of the chain(s), this is called traceplot. Simply plot the parameter values against the steps. Such a traceplot has been shown in Figure 1. We clearly see that the 2 chains have converged to the same region (stationary distribution). Another traceplot is shown in Figure 4.\n\n\n\n\n\n\nFigure 4: Traceplot of the parameter sigma inagainst the steps. While the Metropolis Algorithm provides valid samples, the samples are highly correlated compared to the more advanced Stan algorithm\n\n\n\nThis traceplot compares the parameter \\(a\\) sampled with Stan (a more advanced MCMC algorithm) and the Metropolis-Hastings algorithm. We see that the Metropolis-Hastings algorithm moves slowly through the parameter space. In contrast, the Stan samples are less correlated and move more faster through the complete parameter space. This fast moving through the parameter space is called “efficient mixing” or a “hairy caterpillar”. The effect of this “hairy caterpillar” is that the samples are less correlated and hence provide more information about the posterior distribution of the parameter. This can be quantified by the effective sample size (ESS), which is the number of independent samples that provide the same information as the correlated samples.\nFinally, in the case of bimodal distributions, MCMC algorithms can get stuck in one of the modes. This is shown in Figure 5 . Some chains of have converged to the one mode and it takes a long time to switch to the other mode. While the true bimodal distribution would be sampled for infinite times it practically takes a long time to sample from both modes and the respecitve modes are not sampled equally.\n\n\n\n\n\n\nFigure 5: Trace Plot of Samples from a Bimodal Distribution, all chains sample the repective mode quite successfully but stay too long in a mode before jumping to the next.\n\n\n\nYou can play around a bit with the overlap of the two modes and the standard deviation of the proposal distribution in https://oduerr.github.io/anim/mcmc_mh.html"
  },
  {
    "objectID": "lecture_notes/MCMC/MCMC.html#continuous-case-details",
    "href": "lecture_notes/MCMC/MCMC.html#continuous-case-details",
    "title": "Lecture Notes on MCMC",
    "section": "🤔 Continuous case details*",
    "text": "🤔 Continuous case details*\n*This is and advanced topic, which might be well skipped on first reading.\nLet’s look at the continous case in more detail. We derived the Metropolis-Hastings algorithm for the discrete case, where we have probabilities and not densities. The MH acceptance probability is given by\n\\[\nA_{ij} = \\min (1, \\frac{T_{ji}P_i}{T_{ij} P_j})\n\\]\nThe probability \\(P_i\\) for the state \\(\\theta_i\\) is replaced by the density \\(p(\\theta_i)\\) times the infinitisimal volume element \\(d\\theta_i\\). The transition probability \\(T_{ji}\\) that starting in \\(i\\) we move to \\(j\\) is replaced by the proposal density \\(T(\\theta_j|\\theta_i)\\) times the infinitisimal volume element \\(d\\theta_j\\). Note we have a probability in the target volumne \\(d\\theta_j\\) and not in the “from” volume \\(d\\theta_i\\). So altogether we get\n\\[\nA(\\theta_i \\leftarrow \\theta_j) = \\min \\left(1, \\frac{d\\theta_j T(\\theta_j|\\theta_i) p(\\theta_i) d\\theta_i}{d\\theta_i T(\\theta_i|\\theta_j) p(\\theta_j) d\\theta_j}\\right)\n\\] Note that the volume elements \\(d\\theta_i\\) and \\(d\\theta_j\\) cancel out. So we get\n\\[\nA(\\theta_i \\leftarrow \\theta_j) = \\min \\left(1, \\frac{T(\\theta_j|\\theta_i) p(\\theta_i)}{T(\\theta_i|\\theta_j) p(\\theta_j) }\\right)\n\\tag{1}\\] Which is the same as in the discrete case! However, there might be pitfalls when changing to the continuous case, don’t just replace the probabilities \\(P_i\\) with densities \\(p(\\theta)\\)! This is for example the case in the following.\n\n\n\n\n\n\nNote\n\n\n\nThe MH Criterion is the same in the continuous case as in the discrete case. Just replace the probabilities with densities.\n\n\n\n⚠️ Sampling in a different space\nThere are several reasons, to sample in a different space, then the space where the target distribution \\(p(\\theta)\\) is defined. It might be hard to sample in \\(\\theta\\), but it’s easy to sample in another space \\(x\\). For example in \\(\\theta\\) the probability landscape might have very narrow regions, but in \\(x\\) it’s much nicer behaved. We will encounter this in the famous Neal’s funnel example later. Another reason is that \\(\\theta\\) is in a restricted space. We will use the following example in spherical coordinates to illustrate this. Suppose we have a problem where we have a good idea that the radius \\(r\\) is around 1, but we have no idea about the angle \\(\\varphi\\). We can express this in the following prior\n\\[\np(\\theta) = p(r,\\varphi) = p(r)p(\\varphi) = N(r|1,0.1) \\cdot U(\\varphi|0,2\\pi)\n\\] Assume, we have no data, then the Target Distribution is then given by \\(p(r,\\varphi) \\propto N(r|1,0.1)\\). Note that in this space, we have restrictions on the parameters \\(r &gt; 0\\) and \\(0 \\le \\varphi &lt; 2\\pi\\). We have to design the proposal density \\(T(\\theta^*|\\theta)\\) such that these restrictions are intact. While this is possible in the Metropolis-Hastings algorithm, it’s really hard to enforce this in more advanced algorithms like Hamiltonian Monte Carlo, where we need an unrestricted space. To solve this we transform the problem in a difference space \\(x\\), where we have no restrictions. The acceptance probability is then Equation 1 with \\(\\theta\\) replaced by \\(x\\).\n\\[\nA(x_i \\leftarrow x_j) = \\min \\left(1, \\frac{T(x_j|x_i) p(x_i)}{T(x_i|x_j) p(x_j) }\\right)\n\\tag{2}\\]\nSo what is missing is \\(p(x)\\). Be careful and consider probabilities:\n\\[\n  p(x) dx = p(\\theta) d\\theta \\quad \\Rightarrow \\quad p(x) = p(\\theta) \\left| \\frac{d \\theta}{d x} \\right|\n\\] With the Jacobian Determinant \\(J = \\left| \\frac{d\\theta}{dx} \\right|\\), e.g. Equation 1 becomes:\n\\[\nA(\\theta_i \\leftarrow \\theta_j) = \\min \\left(1, \\frac{T(\\theta_j|\\theta_i) p(\\theta_i)}{T(\\theta_i|\\theta_j) p(\\theta_j)} \\right) = \\min \\left(1, \\frac{T(x_j|x_i) p(x_i) J_i}{T(x_i|x_j) p(x_j) J_j} \\right)\n\\]\nWe have \\(x_1 = r \\cos(\\varphi)\\) and \\(x_2 = r \\sin(\\varphi)\\), so calculation of \\(\\frac{d x}{d \\theta}\\) would be simple, so we calculate the inverse of the Jacobian Determinant: \\[\nJ^{-1} =\n\\left|\n\\begin{pmatrix}\n\\frac{\\partial x_1}{\\partial r} & \\frac{\\partial x_1}{\\partial \\varphi} \\\\\n\\frac{\\partial x_2}{\\partial r} & \\frac{\\partial x_2}{\\partial \\varphi}\n\\end{pmatrix}\n\\right|\n=\n\\left|\n\\begin{pmatrix}\n\\cos(\\varphi) & -r \\sin(\\varphi) \\\\\n\\sin(\\varphi) & r \\cos(\\varphi)\n\\end{pmatrix}\n\\right| = r (\\cos^2(\\varphi) + \\sin^2(\\varphi)) = r\n\\] The Jacobian Determinant is then \\(J = 1/r\\). We can now sample in the unrestricted space \\(x_1\\) and \\(x_2\\) and apply the Jacobian Determinant. The following code snippet shows how to sample from the target distribution in unrestricted space \\(x_1\\) and \\(x_2\\) and how to correctly apply the Jacobian Determinant.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n⚠ Likelihood in different space\nConsider the where are in a parameter space \\(\\theta\\) and we have in that space the likelihood \\(p_\\theta(D|\\theta)\\) and prior \\(p_\\theta(\\theta))\\) and thus the posterior is\n\\[\np_\\theta(\\theta|D) \\propto p_\\theta(D|\\theta) p_\\theta(\\theta)\n\\]\nWe now transform in an different space \\(\\varphi\\) with the transformation \\(\\theta = f(\\varphi)\\). The likelihood in the new space is then given by \\(p_\\varphi(D|\\varphi)\\) and the prior by \\(p_\\varphi(\\varphi)\\) and hence the posterior is\n\\[\np_\\varphi(\\varphi|D) \\propto p_\\varphi(D|\\varphi) p_\\varphi(\\varphi)\n\\]\nOf course we can sample, evaluate the likelihood and prior in either space and get the same result. What happens if we sample in the \\(\\varphi\\) space\n\nStart with \\(\\varphi_0\\)\nPropose \\(\\varphi^*\\) from \\(\\varphi_0\\) with \\(T(\\varphi^*|\\varphi_0)\\)\nCalculate the unnormalized posterior in the \\(\\varphi\\) space \\(p_\\varphi(D|\\varphi^*) p_\\varphi(\\varphi^*)\\)\nAssuming a symetric proposal distribution \\(T(\\varphi^*|\\varphi_0) = T(\\varphi_0|\\varphi^*)\\) we get the Metropolis-Hastings acceptance probability from the ratio \\(p_\\varphi(D|\\varphi^*) p_\\varphi(\\varphi^*)/p_\\varphi(D|\\varphi_0) p_\\varphi(\\varphi_0)\\).\n\nIs it OK to calculate the likelihood in the \\(\\theta\\) space by the transformed \\(\\varphi\\)? For that the ratio of the likelihoods \\(p_\\theta(D|f(\\varphi^*)) /p_\\theta(D|f(\\varphi_0)) \\overbrace{=}^{!}  p_\\varphi(D|\\varphi^*) /p_\\varphi(D|\\varphi_0)\\) needs to be the same.\nLet’s make a concrete Example."
  },
  {
    "objectID": "lecture_notes/MCMC/MCMC.html#footnotes",
    "href": "lecture_notes/MCMC/MCMC.html#footnotes",
    "title": "Lecture Notes on MCMC",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWell actually its a density plot plot(density(.)) and not hist(.)↩︎"
  },
  {
    "objectID": "Euro24/euro24.html",
    "href": "Euro24/euro24.html",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "",
    "text": "The Euro 2024 ⚽ is a nice showcase of Bayesian Statistics. In Bayesian statistics, probabilities are seen as a degree of belief, which fits well with the nature of football. Almost everyone has beliefs about the strengths and weaknesses of the teams before seeing any games (based on historical data) and then updates these beliefs as new data comes in (games have been played)."
  },
  {
    "objectID": "Euro24/euro24.html#prediction-based-on-the-historical-data",
    "href": "Euro24/euro24.html#prediction-based-on-the-historical-data",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "Prediction based on the Historical Data",
    "text": "Prediction based on the Historical Data\nWe load the matches prior to the Euro 2024, see https://github.com/oduerr/da/blob/master/stan/Euro24/Euro_Data.md how to get the data. Note the limitations of using historic; for example, Germany only started finding their form shortly before Euro 2024."
  },
  {
    "objectID": "Euro24/euro24.html#loading-the-data",
    "href": "Euro24/euro24.html#loading-the-data",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "Loading the data",
    "text": "Loading the data\nLoaded 116 games with 24 teams.\n\n\n\n\n\n\nExpand To Learn How to set up the data for Stan\n\n\n\n\n\nPreparing the data for Stan\n\n\nCode\n#Some R-Magic to convert the team names to numbers, no need to understand this\nng = nrow(data)\nteams = unique(data$Home)\nnt = length(teams)\nht = unlist(sapply(1:ng, function(g) which(teams == data$Home[g])))\nat = unlist(sapply(1:ng, function(g) which(teams == data$Away[g])))\n\nnp=1 #Number games leaving out for prediction\nngob = ng-np #ngames obsered ngob = number of games to fit\n#print(paste0(\"Using the first \", ngob, \" games to fit the model and \", np, \" games to predict.\", \"Num teams \",  length(teams)))\nmy_data = list(\n  nt = nt, \n  ng = ngob,\n  ht = ht[1:ngob], \n  at = at[1:ngob], \n  s1 = data$score1[1:ngob],\n  s2 = data$score2[1:ngob],\n  np = np,\n  htnew = ht[(ngob+1):ng],\n  atnew = at[(ngob+1):ng]\n)\n\n\nUsing the first 115 games to fit the model and 1 games to predict. In total we have 24 teams."
  },
  {
    "objectID": "Euro24/euro24.html#preparing-the-data-for-stan",
    "href": "Euro24/euro24.html#preparing-the-data-for-stan",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "Preparing the data for Stan",
    "text": "Preparing the data for Stan\n\n\nCode\n#Some R-Magic to convert the team names to numbers, no need to understand this\nng = nrow(data)\nteams = unique(data$Home)\nnt = length(teams)\nht = unlist(sapply(1:ng, function(g) which(teams == data$Home[g])))\nat = unlist(sapply(1:ng, function(g) which(teams == data$Away[g])))\n\nnp=1 #Number games leaving out for prediction\nngob = ng-np #ngames obsered ngob = number of games to fit\n#print(paste0(\"Using the first \", ngob, \" games to fit the model and \", np, \" games to predict.\", \"Num teams \",  length(teams)))\nmy_data = list(\n  nt = nt, \n  ng = ngob,\n  ht = ht[1:ngob], \n  at = at[1:ngob], \n  s1 = data$score1[1:ngob],\n  s2 = data$score2[1:ngob],\n  np = np,\n  htnew = ht[(ngob+1):ng],\n  atnew = at[(ngob+1):ng]\n)\n\n\nUsing the first 115 games to fit the model and 1 games to predict. In total we have 24 teams."
  },
  {
    "objectID": "Euro24/euro24.html#a-model-for-the-goals-scored",
    "href": "Euro24/euro24.html#a-model-for-the-goals-scored",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "A Model for the goals scored 🥅",
    "text": "A Model for the goals scored 🥅\nWe will assume that the number of goals scored by the home team \\(s_1\\) and the away team \\(s_2\\) follows a Poisson distribution. This has been shown to be a good model for the number of goals scored in a football match. We model the rate parameter \\(\\theta\\) of the Poisson distribution, related to the attack and defense strengths of the teams, as follows:\n\\[\n    s_1 \\sim \\text{Pois}(\\theta_1) \\quad\\text{goals scored by the home team}\n\\]\n\\[\n    s_2 \\sim \\text{Pois}(\\theta_2) \\quad\\text{goals scored by the away team}\n\\]\nThis is equivalent to performing two separate Poisson regressions, one for each team.\nWe assume that:\n\\[\n    \\theta_1 = \\exp(\\text{home} + \\text{att}_\\text{ht} - \\text{def}_\\text{at})\n\\]\n\\[\n    \\theta_2 = \\exp(\\text{att}_\\text{at} - \\text{def}_\\text{ht})\n\\]\nSince there is no home advantage in the Euro (except for Germany), we set \\(\\text{home} = 0\\).\n\nPrior for the attack and defence strength\nIn Bayesian statistics, we further need to specify a prior for the parameters (our degree of believe in the attack and defense abilities before seeing any data). For that we use a hierarchical model with correlated parameters. Other models are investigated at https://github.com/oduerr/da/blob/master/stan/football/Correlated.md for the English Premier League 2019/2020 season where the hiearchical model have been especially successfull. The model is adopted from the blog_post and the paper. We extend the model to include a correlation between the attack and defense strength of the teams, since it is quite reasonable that a team that scores many goals (is above average in offense) is also good in defense."
  },
  {
    "objectID": "Euro24/euro24.html#conditioning-on-the-data-fitting-the-model",
    "href": "Euro24/euro24.html#conditioning-on-the-data-fitting-the-model",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "Conditioning on the data / Fitting the model",
    "text": "Conditioning on the data / Fitting the model\nAfter we state the model we fit the model to the data, or in Bayesian parlance, we update our degree of belief after seeing the data.\n\n\n\n\n\n\nDetails of the model MCMC sampling with Stan\n\n\n\n\n\nThe model is written in the probabilistic programming language Stan and can be found at https://github.com/oduerr/da/blob/master/website/Euro24/hier_model_cor.stan. This model used a Cholesky decomposition to model the correlation between the attack and defense strength of the teams. While this produces very effective sampling and is numerically stable, the Cholesky decomposition adds another layer of complexity to the model. We also provide a model without the Cholesky decomposition at https://github.com/oduerr/da/blob/master/website/Euro24/hier_model_cor_nocholesky.stan which is easier to understand but which is, besides the numerical difficulties, equivalent to the model with the Cholesky decomposition.\n\n\nCode\nlibrary(cmdstanr)\noptions(mc.cores = parallel::detectCores())\nhmodel &lt;- cmdstan_model('~/Documents/GitHub/da/website/Euro24/hier_model_cor.stan')\n#hmodel &lt;- cmdstan_model('~/Documents/GitHub/da/website/Euro24/hier_model_cor_nocholsky.stan')\nhfit = hmodel$sample(data = my_data)\n## Running MCMC with 4 chains, at most 10 in parallel...\n## \n## Chain 1 Iteration:    1 / 2000 [  0%]  (Warmup) \n## Chain 2 Iteration:    1 / 2000 [  0%]  (Warmup) \n## Chain 2 Iteration:  100 / 2000 [  5%]  (Warmup) \n## Chain 2 Iteration:  200 / 2000 [ 10%]  (Warmup) \n## Chain 2 Iteration:  300 / 2000 [ 15%]  (Warmup) \n## Chain 3 Iteration:    1 / 2000 [  0%]  (Warmup) \n## Chain 3 Iteration:  100 / 2000 [  5%]  (Warmup) \n## Chain 3 Iteration:  200 / 2000 [ 10%]  (Warmup) \n## Chain 3 Iteration:  300 / 2000 [ 15%]  (Warmup) \n## Chain 3 Iteration:  400 / 2000 [ 20%]  (Warmup) \n## Chain 4 Iteration:    1 / 2000 [  0%]  (Warmup) \n## Chain 4 Iteration:  100 / 2000 [  5%]  (Warmup) \n## Chain 4 Iteration:  200 / 2000 [ 10%]  (Warmup) \n## Chain 4 Iteration:  300 / 2000 [ 15%]  (Warmup) \n## Chain 1 Iteration:  100 / 2000 [  5%]  (Warmup) \n## Chain 1 Iteration:  200 / 2000 [ 10%]  (Warmup) \n## Chain 1 Iteration:  300 / 2000 [ 15%]  (Warmup) \n## Chain 2 Iteration:  400 / 2000 [ 20%]  (Warmup) \n## Chain 2 Iteration:  500 / 2000 [ 25%]  (Warmup) \n## Chain 2 Iteration:  600 / 2000 [ 30%]  (Warmup) \n## Chain 2 Iteration:  700 / 2000 [ 35%]  (Warmup) \n## Chain 3 Iteration:  500 / 2000 [ 25%]  (Warmup) \n## Chain 3 Iteration:  600 / 2000 [ 30%]  (Warmup) \n## Chain 3 Iteration:  700 / 2000 [ 35%]  (Warmup) \n## Chain 4 Iteration:  400 / 2000 [ 20%]  (Warmup) \n## Chain 4 Iteration:  500 / 2000 [ 25%]  (Warmup) \n## Chain 4 Iteration:  600 / 2000 [ 30%]  (Warmup) \n## Chain 4 Iteration:  700 / 2000 [ 35%]  (Warmup) \n## Chain 4 Iteration:  800 / 2000 [ 40%]  (Warmup) \n## Chain 1 Iteration:  400 / 2000 [ 20%]  (Warmup) \n## Chain 1 Iteration:  500 / 2000 [ 25%]  (Warmup) \n## Chain 1 Iteration:  600 / 2000 [ 30%]  (Warmup) \n## Chain 1 Iteration:  700 / 2000 [ 35%]  (Warmup) \n## Chain 2 Iteration:  800 / 2000 [ 40%]  (Warmup) \n## Chain 2 Iteration:  900 / 2000 [ 45%]  (Warmup) \n## Chain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup) \n## Chain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling) \n## Chain 3 Iteration:  800 / 2000 [ 40%]  (Warmup) \n## Chain 3 Iteration:  900 / 2000 [ 45%]  (Warmup) \n## Chain 3 Iteration: 1000 / 2000 [ 50%]  (Warmup) \n## Chain 3 Iteration: 1001 / 2000 [ 50%]  (Sampling) \n## Chain 3 Iteration: 1100 / 2000 [ 55%]  (Sampling) \n## Chain 4 Iteration:  900 / 2000 [ 45%]  (Warmup) \n## Chain 4 Iteration: 1000 / 2000 [ 50%]  (Warmup) \n## Chain 4 Iteration: 1001 / 2000 [ 50%]  (Sampling) \n## Chain 4 Iteration: 1100 / 2000 [ 55%]  (Sampling) \n## Chain 1 Iteration:  800 / 2000 [ 40%]  (Warmup) \n## Chain 1 Iteration:  900 / 2000 [ 45%]  (Warmup) \n## Chain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup) \n## Chain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling) \n## Chain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling) \n## Chain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling) \n## Chain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling) \n## Chain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling) \n## Chain 3 Iteration: 1200 / 2000 [ 60%]  (Sampling) \n## Chain 3 Iteration: 1300 / 2000 [ 65%]  (Sampling) \n## Chain 4 Iteration: 1200 / 2000 [ 60%]  (Sampling) \n## Chain 4 Iteration: 1300 / 2000 [ 65%]  (Sampling) \n## Chain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling) \n## Chain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling) \n## Chain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling) \n## Chain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling) \n## Chain 3 Iteration: 1400 / 2000 [ 70%]  (Sampling) \n## Chain 3 Iteration: 1500 / 2000 [ 75%]  (Sampling) \n## Chain 4 Iteration: 1400 / 2000 [ 70%]  (Sampling) \n## Chain 4 Iteration: 1500 / 2000 [ 75%]  (Sampling) \n## Chain 4 Iteration: 1600 / 2000 [ 80%]  (Sampling) \n## Chain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling) \n## Chain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling) \n## Chain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling) \n## Chain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling) \n## Chain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling) \n## Chain 3 Iteration: 1600 / 2000 [ 80%]  (Sampling) \n## Chain 3 Iteration: 1700 / 2000 [ 85%]  (Sampling) \n## Chain 4 Iteration: 1700 / 2000 [ 85%]  (Sampling) \n## Chain 4 Iteration: 1800 / 2000 [ 90%]  (Sampling) \n## Chain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling) \n## Chain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling) \n## Chain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling) \n## Chain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling) \n## Chain 2 Iteration: 2000 / 2000 [100%]  (Sampling) \n## Chain 3 Iteration: 1800 / 2000 [ 90%]  (Sampling) \n## Chain 3 Iteration: 1900 / 2000 [ 95%]  (Sampling) \n## Chain 3 Iteration: 2000 / 2000 [100%]  (Sampling) \n## Chain 4 Iteration: 1900 / 2000 [ 95%]  (Sampling) \n## Chain 4 Iteration: 2000 / 2000 [100%]  (Sampling) \n## Chain 2 finished in 0.8 seconds.\n## Chain 3 finished in 0.8 seconds.\n## Chain 4 finished in 0.7 seconds.\n## Chain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling) \n## Chain 1 Iteration: 2000 / 2000 [100%]  (Sampling) \n## Chain 1 finished in 0.9 seconds.\n## \n## All 4 chains finished successfully.\n## Mean chain execution time: 0.8 seconds.\n## Total execution time: 1.0 seconds.\np1 = bayesplot::mcmc_rhat_hist(bayesplot::rhat(hfit))\np2 = bayesplot::mcmc_neff_hist(bayesplot::neff_ratio(hfit))\nggpubr::ggarrange(p1, p2, ncol=2)\n\n\n\n\n\n\n\n\n\nThe fitting of the model is good, as the Rhat values are close to 1 and we have no divergent transitions. The effective sample size is also good."
  },
  {
    "objectID": "Euro24/euro24.html#the-fitted-model",
    "href": "Euro24/euro24.html#the-fitted-model",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "The fitted model",
    "text": "The fitted model\nWe plot the means of the attack and defense strengths of the teams. Shown are the mean values along with the 25% and 75% quantiles. There is considerable uncertainty in the strengths of the teams, but that’s the nature of the game.\n\n\nCode\nlibrary(tidyverse)\nlibrary(tidybayes)\n\n# Step 1: Gather draws and calculate summary statistics with credible intervals\nd = hfit %&gt;%\n  tidybayes::gather_draws(A[i, j]) %&gt;%\n  group_by(i, j) %&gt;%\n  summarise(\n    average_value = mean(.value),\n    lower = quantile(.value, 0.25),  # Lower bound \n    upper = quantile(.value, 0.75),  # Upper bound \n    .groups = \"drop\"\n  )\n\n# Step 2: Create a matrix of the average values\nA = xtabs(average_value ~ i + j, data = d)\n\n# Step 3: Plot the average values\nplot(A[1,], A[2,], pch=20, xlab='Attack', ylab='Defence', main='Attack vs Defence')\n\n# Step 4: Add team labels\ntext(A[1,], A[2,], labels=teams, cex=0.7, adj=c(-0.05, -0.8))\n\n# Step 5: Add error bars for 66% credibility intervals\n# Reshape data for plotting\nd_wide &lt;- d %&gt;% spread(key = j, value = average_value)\nd_lower &lt;- d %&gt;% spread(key = j, value = lower)\nd_upper &lt;- d %&gt;% spread(key = j, value = upper)\n\n# Convert to matrices for easier plotting\nA_lower &lt;- xtabs(lower ~ i + j, data = d)\nA_upper &lt;- xtabs(upper ~ i + j, data = d)\n\n# Plot vertical error bars\narrows(A[1,], A_lower[2,], A[1,], A_upper[2,], angle=90, code=3, length=0.05, col=\"lightblue\", alpha=0.5)\n\n# Plot horizontal error bars\narrows(A_lower[1,], A[2,], A_upper[1,], A[2,], angle=90, code=3, length=0.05, col=\"lightblue\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDetailed explanations for a single match Germany vs Scotland\n\n\n\n\n\nThe opening game of Euro 2024 was Germany vs. Scotland. In the plots below, we show the posterior probabilities for the attack and defense strengths of the teams.\n\n\nCode\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(tidybayes)\n\n# Function to calculate probabilities for a pairing\nid1 &lt;- which(teams == 'Germany')\nid2 &lt;- which(teams == 'Scotland')\n\n# Extract posterior distributions for Attack and Defense\nattack_germany &lt;- hfit %&gt;% tidybayes::spread_draws(A[i, j]) %&gt;% filter(j == id1, i == 1) %&gt;% select(A)\nattack_scotland &lt;- hfit %&gt;% tidybayes::spread_draws(A[i, j]) %&gt;% filter(j == id2, i == 1) %&gt;% select(A)\ndefense_germany &lt;- hfit %&gt;% tidybayes::spread_draws(A[i, j]) %&gt;% filter(j == id1, i == 2) %&gt;% select(A)\ndefense_scotland &lt;- hfit %&gt;% tidybayes::spread_draws(A[i, j]) %&gt;% filter(j == id2, i == 2) %&gt;% select(A)\n\n# Combine data into a tidy data frame\ntidy_df &lt;- bind_rows(\n  attack_germany %&gt;% mutate(Statistic = \"Attack\", Country = \"Germany\"),\n  attack_scotland %&gt;% mutate(Statistic = \"Attack\", Country = \"Scotland\"),\n  defense_germany %&gt;% mutate(Statistic = \"Defense\", Country = \"Germany\"),\n  defense_scotland %&gt;% mutate(Statistic = \"Defense\", Country = \"Scotland\")\n)\n\n# Include the mean values in the plot\nggplot(tidy_df, aes(x = A, fill = Country)) +\n  geom_density(alpha = 0.5) +\n  facet_wrap(~ Statistic, scales = \"free\") +\n  labs(title = \"Posterior Distributions of Attack and Defense Strengths\", x = \"Strength\", y = \"Density\") +\n  geom_vline(data = tidy_df %&gt;% group_by(Statistic, Country) %&gt;% summarise(mean_A = mean(A)), \n             aes(xintercept = mean_A, color = Country), linetype = \"dashed\") +\n  theme_minimal() \n\n\n\n\n\n\n\n\n\n\nMaking predictions\nWe can now make predictions for the game Germany vs Scotland. Below are the first samples of the posterior distribution for the attack and defense strengths of germany and scotland.\n\n\nCode\n# Extract first five samples for demonstration\ndf = data.frame(attack_germany = attack_germany$A, defense_germany = defense_germany$A, attack_scotland = attack_scotland$A, defense_scotland = defense_scotland$A) %&gt;% head() \nknitr::kable(df)\n\n\n\n\n\n\nattack_germany\ndefense_germany\nattack_scotland\ndefense_scotland\n\n\n\n\n-0.0442763\n-0.0242716\n0.163076\n-0.1346680\n\n\n-0.0206877\n0.0249255\n-0.178088\n0.0312232\n\n\n-0.0107814\n-0.1450450\n0.223999\n-0.3913570\n\n\n0.4885000\n0.0832831\n-0.382091\n0.0152179\n\n\n-0.0609140\n-0.3309840\n0.169096\n-0.4265350\n\n\n0.0887341\n0.0641705\n-0.207708\n-0.0027483\n\n\n\n\n\n\n\n\nWe use the samples for posterior row by row to sample the number of goals for Germany and Scotland. We can use the samples to calculate the probability of a win, draw or loss for Germany.\n\n\nCode\n set.seed(42)\n theta_germany = exp(attack_germany$A - defense_scotland$A)\n theta_scotland = exp(attack_scotland$A - defense_germany$A)\n g_germany = rpois(length(theta_germany), theta_germany)\n g_scotland = rpois(length(theta_scotland), theta_scotland)\n mean(g_germany &gt; g_scotland) #Probability of Germany winning\n\n\n[1] 0.458\n\n\nCode\n mean(g_germany == g_scotland) #Probability of a draw\n\n\n[1] 0.2535\n\n\nCode\n mean(g_germany &lt; g_scotland) #Probability of Scotland winning\n\n\n[1] 0.2885\n\n\nCode\n plot(table(g_germany)/length(g_germany), main='Germany Goals', xlab='Goals', ylab='Probability')\n\n\n\n\n\n\n\n\n\nCode\n plot(table(g_scotland)/length(g_scotland), main='Scotland Goals', xlab='Goals', ylab='Probability')\n\n\n\n\n\n\n\n\n\nAnother way to look at is is at the joint distribution of the goals scored\n\n\nCode\nlibrary(tidyverse)\nlibrary(ggplot2)\n\n# Define the function\nplot_goal_probabilities &lt;- function(attack_team1, defense_team1, attack_team2, defense_team2, team1_name = \"Team 1\", team2_name = \"Team 2\") {\n  set.seed(42)\n  \n  # Simulate goals scored using Poisson distribution\n  theta_team1 &lt;- exp(attack_team1 - defense_team2)\n  theta_team2 &lt;- exp(attack_team2 - defense_team1)\n  g_team1 &lt;- rpois(length(theta_team1), theta_team1)\n  g_team2 &lt;- rpois(length(theta_team2), theta_team2)\n  \n  # Calculate joint probabilities\n  joint_prob &lt;- table(g_team1, g_team2) / length(g_team1)\n  df_joint &lt;- as.data.frame(as.table(joint_prob))\n  colnames(df_joint) &lt;- c(\"Goals_Team1\", \"Goals_Team2\", \"Probability\")\n  \n  # Ensure all combinations from 0 to 5 are included\n  all_combinations &lt;- expand.grid(Goals_Team1 = 0:5, Goals_Team2 = 0:5)\n  df_joint &lt;- merge(all_combinations, df_joint, by = c(\"Goals_Team1\", \"Goals_Team2\"), all.x = TRUE)\n  df_joint$Probability[is.na(df_joint$Probability)] &lt;- 0\n  \n  # Calculate outcomes\n  df_joint &lt;- df_joint %&gt;%\n    mutate(\n      Outcome = case_when(\n        Goals_Team1 &gt; Goals_Team2 ~ \"Win1\",\n        Goals_Team1 &lt; Goals_Team2 ~ \"Win2\",\n        TRUE ~ \"Draw\"\n      )\n    )\n  \n  # Calculate probabilities\n  prob_team1_win &lt;- sum(df_joint$Probability[df_joint$Outcome == \"Win1\"])\n  prob_team2_win &lt;- sum(df_joint$Probability[df_joint$Outcome == \"Win2\"])\n  prob_draw &lt;- sum(df_joint$Probability[df_joint$Outcome == \"Draw\"])\n  \n  # Print probabilities to the console\n  # cat(\"Probability of\", team1_name, \"winning: \", prob_team1_win, \"\\n\")\n  # cat(\"Probability of\", team2_name, \"winning: \", prob_team2_win, \"\\n\")\n  # cat(\"Probability of a draw: \", prob_draw, \"\\n\")\n  \n  # Plot the joint probabilities with labels and different colors for outcomes\n  joint_plot &lt;- ggplot(df_joint, aes(x = Goals_Team1, y = Goals_Team2, fill = Outcome)) +\n    geom_tile(color = \"white\", aes(alpha = Probability)) +\n    geom_text(aes(label = sprintf(\"%.2f\", Probability)), color = \"black\", size = 3) +\n    scale_fill_manual(values = c(\"Win1\" = \"blue\", \"Win2\" = \"red\", \"Draw\" = \"green\"), guide = NULL) +\n    scale_alpha(range = c(0.3, 1), guide = NULL) +\n    labs(title = paste0(team1_name, \" vs. \", team2_name),  x = paste(\"Goals by\", team1_name), y = paste(\"Goals by\", team2_name)) +\n    theme_minimal() +\n    theme(\n      plot.title = element_text(hjust = 0.5, size = 14, face = \"bold\"),\n      axis.title = element_text(size = 12),\n      axis.text = element_text(size = 10)\n    ) +\n    scale_x_continuous(limits = c(-0.5, 9), breaks = 0:4) +\n    scale_y_continuous(limits = c(-0.5, 5.5), breaks = 0:5) +\n    annotate(\"text\", x = 5.7, y = 4, label = sprintf(\"%s Wins: %.2f\", team1_name, prob_team1_win), color = \"blue\", size = 3, hjust = 0) +\n    annotate(\"text\", x = 5.7, y = 3, label = sprintf(\"Draw: %.2f\", prob_draw), color = \"green\", size = 3, hjust = 0) +\n    annotate(\"text\", x = 5.7, y = 2, label = sprintf(\"%s Wins: %.2f\", team2_name, prob_team2_win), color = \"red\", size = 3, hjust = 0)\n  \n  # Print the joint plot\n  return(joint_plot)\n}\n\n# Call the function\nplot_goal_probabilities(attack_team1=attack_germany$A, defense_team1 = defense_germany$A, \n                        attack_team2=attack_scotland$A, defense_team2 = defense_scotland$A, team1_name=\"Germany\", team2_name=\"Scotland\")\n\n\n\n\n\n\n\n\n\nRemember the result? It was 5:1 for Germany, so quite unexpected by the model. So that these predictions with a grain of salt. The model is based on historical data and does not take into account the current form of the teams."
  },
  {
    "objectID": "Euro24/euro24.html#details-on-individual-games",
    "href": "Euro24/euro24.html#details-on-individual-games",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "Details on individual games",
    "text": "Details on individual games\n\nGoal Distributions"
  },
  {
    "objectID": "Euro24/euro24.html#germany-vs-scotland",
    "href": "Euro24/euro24.html#germany-vs-scotland",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "1 Germany vs Scotland",
    "text": "1 Germany vs Scotland"
  },
  {
    "objectID": "Euro24/euro24.html#hungary-vs-switzerland",
    "href": "Euro24/euro24.html#hungary-vs-switzerland",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "2 Hungary vs Switzerland",
    "text": "2 Hungary vs Switzerland"
  },
  {
    "objectID": "Euro24/euro24.html#spain-vs-croatia",
    "href": "Euro24/euro24.html#spain-vs-croatia",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "3 Spain vs Croatia",
    "text": "3 Spain vs Croatia"
  },
  {
    "objectID": "Euro24/euro24.html#italy-vs-albania",
    "href": "Euro24/euro24.html#italy-vs-albania",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "4 Italy vs Albania",
    "text": "4 Italy vs Albania"
  },
  {
    "objectID": "Euro24/euro24.html#serbia-vs-england",
    "href": "Euro24/euro24.html#serbia-vs-england",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "5 Serbia vs England",
    "text": "5 Serbia vs England"
  },
  {
    "objectID": "Euro24/euro24.html#slovenia-vs-denmark",
    "href": "Euro24/euro24.html#slovenia-vs-denmark",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "6 Slovenia vs Denmark",
    "text": "6 Slovenia vs Denmark"
  },
  {
    "objectID": "Euro24/euro24.html#poland-vs-netherlands",
    "href": "Euro24/euro24.html#poland-vs-netherlands",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "7 Poland vs Netherlands",
    "text": "7 Poland vs Netherlands"
  },
  {
    "objectID": "Euro24/euro24.html#austria-vs-france",
    "href": "Euro24/euro24.html#austria-vs-france",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "8 Austria vs France",
    "text": "8 Austria vs France"
  },
  {
    "objectID": "Euro24/euro24.html#belgium-vs-slovakia",
    "href": "Euro24/euro24.html#belgium-vs-slovakia",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "9 Belgium vs Slovakia",
    "text": "9 Belgium vs Slovakia"
  },
  {
    "objectID": "Euro24/euro24.html#romania-vs-ukraine",
    "href": "Euro24/euro24.html#romania-vs-ukraine",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "10 Romania vs Ukraine",
    "text": "10 Romania vs Ukraine"
  },
  {
    "objectID": "Euro24/euro24.html#türkiye-vs-georgia",
    "href": "Euro24/euro24.html#türkiye-vs-georgia",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "11 Türkiye vs Georgia",
    "text": "11 Türkiye vs Georgia"
  },
  {
    "objectID": "Euro24/euro24.html#portugal-vs-czechia",
    "href": "Euro24/euro24.html#portugal-vs-czechia",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "12 Portugal vs Czechia",
    "text": "12 Portugal vs Czechia"
  },
  {
    "objectID": "Euro24/euro24.html#scotland-vs-switzerland",
    "href": "Euro24/euro24.html#scotland-vs-switzerland",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "13 Scotland vs Switzerland",
    "text": "13 Scotland vs Switzerland"
  },
  {
    "objectID": "Euro24/euro24.html#germany-vs-hungary",
    "href": "Euro24/euro24.html#germany-vs-hungary",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "14 Germany vs Hungary",
    "text": "14 Germany vs Hungary"
  },
  {
    "objectID": "Euro24/euro24.html#croatia-vs-albania",
    "href": "Euro24/euro24.html#croatia-vs-albania",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "15 Croatia vs Albania",
    "text": "15 Croatia vs Albania"
  },
  {
    "objectID": "Euro24/euro24.html#spain-vs-italy",
    "href": "Euro24/euro24.html#spain-vs-italy",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "16 Spain vs Italy",
    "text": "16 Spain vs Italy"
  },
  {
    "objectID": "Euro24/euro24.html#denmark-vs-england",
    "href": "Euro24/euro24.html#denmark-vs-england",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "17 Denmark vs England",
    "text": "17 Denmark vs England"
  },
  {
    "objectID": "Euro24/euro24.html#slovenia-vs-serbia",
    "href": "Euro24/euro24.html#slovenia-vs-serbia",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "18 Slovenia vs Serbia",
    "text": "18 Slovenia vs Serbia"
  },
  {
    "objectID": "Euro24/euro24.html#poland-vs-austria",
    "href": "Euro24/euro24.html#poland-vs-austria",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "19 Poland vs Austria",
    "text": "19 Poland vs Austria"
  },
  {
    "objectID": "Euro24/euro24.html#netherlands-vs-france",
    "href": "Euro24/euro24.html#netherlands-vs-france",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "20 Netherlands vs France",
    "text": "20 Netherlands vs France"
  },
  {
    "objectID": "Euro24/euro24.html#slovakia-vs-ukraine",
    "href": "Euro24/euro24.html#slovakia-vs-ukraine",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "21 Slovakia vs Ukraine",
    "text": "21 Slovakia vs Ukraine"
  },
  {
    "objectID": "Euro24/euro24.html#belgium-vs-romania",
    "href": "Euro24/euro24.html#belgium-vs-romania",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "22 Belgium vs Romania",
    "text": "22 Belgium vs Romania"
  },
  {
    "objectID": "Euro24/euro24.html#türkiye-vs-portugal",
    "href": "Euro24/euro24.html#türkiye-vs-portugal",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "23 Türkiye vs Portugal",
    "text": "23 Türkiye vs Portugal"
  },
  {
    "objectID": "Euro24/euro24.html#georgia-vs-czechia",
    "href": "Euro24/euro24.html#georgia-vs-czechia",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "24 Georgia vs Czechia",
    "text": "24 Georgia vs Czechia"
  },
  {
    "objectID": "Euro24/euro24.html#switzerland-vs-germany",
    "href": "Euro24/euro24.html#switzerland-vs-germany",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "25 Switzerland vs Germany",
    "text": "25 Switzerland vs Germany"
  },
  {
    "objectID": "Euro24/euro24.html#scotland-vs-hungary",
    "href": "Euro24/euro24.html#scotland-vs-hungary",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "26 Scotland vs Hungary",
    "text": "26 Scotland vs Hungary"
  },
  {
    "objectID": "Euro24/euro24.html#albania-vs-spain",
    "href": "Euro24/euro24.html#albania-vs-spain",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "27 Albania vs Spain",
    "text": "27 Albania vs Spain"
  },
  {
    "objectID": "Euro24/euro24.html#croatia-vs-italy",
    "href": "Euro24/euro24.html#croatia-vs-italy",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "28 Croatia vs Italy",
    "text": "28 Croatia vs Italy"
  },
  {
    "objectID": "Euro24/euro24.html#england-vs-slovenia",
    "href": "Euro24/euro24.html#england-vs-slovenia",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "29 England vs Slovenia",
    "text": "29 England vs Slovenia"
  },
  {
    "objectID": "Euro24/euro24.html#denmark-vs-serbia",
    "href": "Euro24/euro24.html#denmark-vs-serbia",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "30 Denmark vs Serbia",
    "text": "30 Denmark vs Serbia"
  },
  {
    "objectID": "Euro24/euro24.html#netherlands-vs-austria",
    "href": "Euro24/euro24.html#netherlands-vs-austria",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "31 Netherlands vs Austria",
    "text": "31 Netherlands vs Austria"
  },
  {
    "objectID": "Euro24/euro24.html#france-vs-poland",
    "href": "Euro24/euro24.html#france-vs-poland",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "32 France vs Poland",
    "text": "32 France vs Poland"
  },
  {
    "objectID": "Euro24/euro24.html#slovakia-vs-romania",
    "href": "Euro24/euro24.html#slovakia-vs-romania",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "33 Slovakia vs Romania",
    "text": "33 Slovakia vs Romania"
  },
  {
    "objectID": "Euro24/euro24.html#ukraine-vs-belgium",
    "href": "Euro24/euro24.html#ukraine-vs-belgium",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "34 Ukraine vs Belgium",
    "text": "34 Ukraine vs Belgium"
  },
  {
    "objectID": "Euro24/euro24.html#georgia-vs-portugal",
    "href": "Euro24/euro24.html#georgia-vs-portugal",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "35 Georgia vs Portugal",
    "text": "35 Georgia vs Portugal"
  },
  {
    "objectID": "Euro24/euro24.html#czechia-vs-türkiye",
    "href": "Euro24/euro24.html#czechia-vs-türkiye",
    "title": "Bayes is coming home - Predicting the Euro 2024 with Stan",
    "section": "36 Czechia vs Türkiye",
    "text": "36 Czechia vs Türkiye"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Internal Notes for authoring the website\n\nHow to add a new page\n\nCreate a new quarto file in the root directory or subdirectory. Put the quarto-file in website directory (or subdirectory). Make sure that you do not have self-contained: true in the qmd file, otherwise file gets to large. An example is website/lecture_notes/MCMC/MCMC.qmd\n\n\n---\ntitle: \"Lecture Notes on MCMC\"\nauthor: \"Oliver Dürr\"\nformat: \n  html:\n    toc: true\n    toc-title: \"Table of Contents\"\n    toc-depth: 3\n    fig-width: 6\n    fig-height: 3\n    code-fold: true\n    code-tools: true\n    mathjax: true\n  #  self-contained: true &lt;------ NEEDS TO BE COMMENTED OUT (or not there at all)\n  # pdf:\n  #   toc: true\n  #   toc-title: \"Table of Contents\"\nfilters:\n  - webr\n---\n\n\n\nHow to render the website\n\nRender and move to docs folder\n\nquarto render \n\nCheck in the changes in the docs folder\n\n\n\nDevelopment (in da/website)\nquarto preview lecture_notes/MCMC/MCMC.qmd #For a single file\nquarto preview #For the complete website"
  }
]