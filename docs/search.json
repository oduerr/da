[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "da_website",
    "section": "",
    "text": "This is a collection of bits and pieces useful in connection with data analysis."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Stan_Primer_Full.html",
    "href": "Stan_Primer_Full.html",
    "title": "Stan primer",
    "section": "",
    "text": "A quick summary of commands (for a more details see below).\n\n\n\n\nCode\nlibrary(rstan)\noptions(mc.cores = parallel::detectCores())\nrstan_options(javascript=FALSE) #Prevents freezes of RStudio (Jan 2023) \n\nm_rstan = stan_model(model_code = stan_code) #Compiling from string\nm_rstan = stan_model(file='mymodel.stan') #Compiling from file\ns_rstan = sampling(m_rstan, data=data) #Sampling from file\n\n#No MCMC just evaluating parameters\nsampling(model_1, data=dat, algorithm=\"Fixed_param\", chain=1, iter=1) \n\n\n\n\n\n\n\nCode\nlibrary(cmdstanr)\nm_rcmdstan <- cmdstan_model(file_stan)\ns_rcmdstan = m_rcmdstan$sample(data = data)\n\n\n\n\n\n\n\nCode\nlibrary(tidybayes)\nspread_draws(s, c(a,b)) #Extracts a and b from s (stan or cmdstan samples)\nspread_draws(s, f[i])  #Extracts vector f and calls components i\n\n\n\n\n\nSometimes R gets slow when dealing with stan. At least in my case\nrstan_options(javascript=FALSE)\n#In a more detail In the following some notes on Stan. You might find the following resources helpful.\n\n\n\n\nhttp://www.sumsar.net/files/posts/2017-bayesian-tutorial-exercises/stan_cheat_sheet2.12.pdf\nhttps://github.com/sieste/Stan_cheatsheet\n\n\n\n\nSome Data for linear regression\n\n\nCode\nN = 4\nx = c(-2.,-0.66666, 0.666, 2.)\ny = c(-6.25027354, -2.50213382, -6.07525495,  7.92081243)\ndata = list(N=N, x=x, y=y)\n\n\n\n\n\nThere are currently (2023) two interfaces to stan from R. RStan (https://mc-stan.org/users/interfaces/rstan) which is a bit slower and does not use the latest stan compiler and rcmdstan (https://mc-stan.org/cmdstanr/articles/cmdstanr.html).\n\n\nThere are 3 steps:\n\nDefining the model\nCompiling the model. In this step C code is generated.\nRunning the simulation / sampling from the posterior\nExtracting the samples from the posterior\n\n\n\n\nTo define a model, you can add a string or create a .stan file. Another option is to use a Stan markdown chunk and output.var=my_model to the name of the model. Code completion and highlighting is working for files and code chunks.\n\n\nCode\nstan_code = \"data{\n  int<lower=0> N;\n  vector[N] y;\n  vector[N] x;\n}\n\nparameters{\n  real a; //Instead of using e.g. half Gaussian\n  real b;\n  real<lower=0> sigma;\n}\n\nmodel{\n  //y ~ normal(mu, sigma);\n  y ~ normal(a * x + b, sigma);\n  a ~ normal(3, 10); \n  b ~ normal(0, 10); \n  sigma ~ normal(0,10);\n}\"\n\n\n\n\n\nCompiling works with:\n\nCompiling rstan stan_model(model_code = stan_code) or stan_model(file='mymodel.stan')\nCompiling cmdstan cmdstan_model(file_stan)\n\n\n\n\n\nCode\n  library(rstan)\n\n\nLoading required package: StanHeaders\n\n\nrstan (Version 2.21.2, GitRev: 2e1f913d3ca3)\n\n\nFor execution on a local, multicore CPU with excess RAM we recommend calling\noptions(mc.cores = parallel::detectCores()).\nTo avoid recompilation of unchanged Stan programs, we recommend calling\nrstan_options(auto_write = TRUE)\n\n\n\nAttaching package: 'rstan'\n\n\nThe following object is masked from 'package:tidyr':\n\n    extract\n\n\nCode\n  m_rstan = stan_model(model_code = stan_code)\n\n\nTrying to compile a simple C file\n\n\n\n\n\n\nThere is no possibility to use a string for cmd_stan. There is a convenience function rethinking::cmdstanr_model_write. TODO make oduerr utils and provide the file.\n\n\nCode\n  library(cmdstanr)\n\n\nWarning: package 'cmdstanr' was built under R version 4.3.0\n\n\nThis is cmdstanr version 0.5.2\n\n\n- CmdStanR documentation and vignettes: mc-stan.org/cmdstanr\n\n\n- CmdStan path: /Users/oli/.cmdstan/cmdstan-2.29.2\n\n\n- CmdStan version: 2.29.2\n\n\n\nA newer version of CmdStan is available. See ?install_cmdstan() to install it.\nTo disable this check set option or environment variable CMDSTANR_NO_VER_CHECK=TRUE.\n\n\nCode\n  file_stan <- tempfile(fileext=\".stan\")\n  fileConn <- file(file_stan)\n  writeLines(stan_code, fileConn)\n  close(fileConn)\n  m_rcmdstan <- cmdstan_model(file_stan)\n\n\n\n\n\nFor rstan: sampling(m_rstan, data=data) For cmdstan: mod$sample(data = data_file, seed=123)\n\n\nCode\n  s_rcmdstan = m_rcmdstan$sample(data = data)\n\n\nWarning: 1 of 4000 (0.0%) transitions ended with a divergence.\nSee https://mc-stan.org/misc/warnings for details.\n\n\n\n\nCode\n  s_rstan = sampling(m_rstan, data=data)  \n\n\n\n\n\nThe package bayesplot can handle both interfaces\n\n\n\n\nCode\n#traceplot(s_rstan, 'a')\nbayesplot::mcmc_trace(s_rstan)\n\n\n\n\n\nCode\n#bayesplot::mcmc_trace(s_rcmdstan$draws()) #similar result\ns_rstan\n\n\nInference for Stan model: 4bc92a844d593bcbe180a8a2fc11ffa0.\n4 chains, each with iter=2000; warmup=1000; thin=1; \npost-warmup draws per chain=1000, total post-warmup draws=4000.\n\n       mean se_mean   sd   2.5%   25%   50%   75% 97.5% n_eff Rhat\na      2.91    0.05 2.51  -2.42  1.51  2.91  4.37  8.11  2147    1\nb     -1.43    0.08 3.64  -8.53 -3.57 -1.50  0.52  6.45  2214    1\nsigma  7.40    0.09 3.54   3.03  4.78  6.61  9.12 16.37  1435    1\nlp__  -7.99    0.04 1.46 -11.52 -8.73 -7.65 -6.91 -6.20  1059    1\n\nSamples were drawn using NUTS(diag_e) at Thu Jan  5 09:49:06 2023.\nFor each parameter, n_eff is a crude measure of effective sample size,\nand Rhat is the potential scale reduction factor on split chains (at \nconvergence, Rhat=1).\n\n\nCode\n# Rhat close to one and n_eff lager than half the number of draws; look fine\n\n\nKey Numbers\n\nRhat is something like the ratio of variation between the chains to withing the chains\nn_eff number of effective samples taking the autocorrelation into account (in cmd_stan the output is ess_bulk and ess_tail)\n\n\n\n\n\n\nCode\n  #Shiny Stan, quite overwhelming\n  library(shinystan)\n  launch_shinystan(samples)\n\n\n\n\n\n\n\nGetting the samples can be done as\n\nRstan extract(s_rstan)\ncmdstan s_rcmdstan$draws()\n\nAnother handy package is tidybayes which can handle the output of rstan and rcmdstan\n\n\nCode\nlibrary(tidybayes)\nhead(spread_draws(s_rcmdstan, c(a,b))) #Non-tidy a and b in one row\n\n\n# A tibble: 6 × 5\n  .chain .iteration .draw     a     b\n   <int>      <int> <int> <dbl> <dbl>\n1      1          1     1 0.415  1.35\n2      1          2     2 4.44  -3.09\n3      1          3     3 2.56  -1.58\n4      1          4     4 1.54  -4.78\n5      1          5     5 2.89  -2.44\n6      1          6     6 2.68  -5.39\n\n\nCode\nhead(gather_draws(s_rstan, c(a,b))) #The ggplot like syntax\n\n\n# A tibble: 6 × 5\n# Groups:   .variable [1]\n  .chain .iteration .draw .variable .value\n   <int>      <int> <int> <chr>      <dbl>\n1      1          1     1 a          8.14 \n2      1          2     2 a          6.76 \n3      1          3     3 a          0.670\n4      1          4     4 a          5.24 \n5      1          5     5 a          1.95 \n6      1          6     6 a         -1.12 \n\n\nCode\n#spread_draws(model_weight_sex, a[sex]) for multilevel models\n\n\n\n\n\n\nCode\n  #plot(samples)\n  #samples = extract(s_rstan)\n  stan_dens(s_rstan)\n\n\n\n\n\nCode\n  #Note that these are marginals!\n\n\n\n\n\nWe extract samples from the posterior via extract (in some installation the wrong extract function is taken in that case use rstan::extract to use the right one). Visualize the posterior distribution of \\(a\\) from the samples.\n\n\nCode\n# Extract samples\npost = rstan::extract(s_rstan)\nT = length(post$a)\nhist(post$a,100, freq=F)\nlines(density(post$a),col='red')  \n\n\n\n\n\n\n\nUsing the pairs plot, correlations in the variables can be found.\n\n\nCode\nnp_cp = bayesplot::nuts_params(s_rstan)\nbayesplot::mcmc_pairs(s_rstan, np = np_cp,pars = c(\"a\",\"b\"))\n\n\n\n\n\n\n\n\n\n\n\n\nSome background first: posterior predictive distribution: \\[\n  p(y|x, D) =  \\int p(y|x,\\theta) p(\\theta|D) \\; d\\theta\n\\] Instead of integration, we sample in two turns\n\n\\(\\theta_i \\sim p(\\theta|D)\\)\n\\(y_{ix} \\sim p(y|x,\\theta_i)\\) #We do this for many x in practice\n\n\n\n\nYou can either do this part, or use stan to create the posterior predictive samples \\(y_{ix}\\) from the samples \\(\\theta_i\\) by hand.\nTip: Create two matrices yix and muix from the posterior samples of \\(a,b,\\sigma\\) with dimension (rows = number of posterior samples and cols = number of x positions).\n\n\nCode\nxs = -10:15 # The x-range 17 values from -1 to 15\nM = length(xs) \nyix = matrix(nrow=T, ncol = M) #Matrix from samples (number of posterior draws vs number of xs)\nmuix = matrix(nrow=T, ncol = M) #Matrix from mu (number of posterior draws vs number of xs)\nfor (i in 1:T){ #Samples from the posterior\n  a = post$a[i] #Corresponds to samples from theta\n  b = post$b[i]\n  sigma = post$sigma[i]\n  for (j in 1:M){ #Different values of X\n    mu = a * xs[j] + b\n    muix[i,j] = a * xs[j] + b\n    yix[i,j] = rnorm(1, mu, sigma) # Single number drawn\n  }\n}\n\nif (FALSE){\n  plot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='mu=a*x+b')\n  for (i in 1:100){\n    lines(xs, muix[i,],lwd=0.25,col='blue')\n  }\n  \n  plot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='ys')\n  for (i in 1:100){\n    points(xs, yix[i,], pch='.',col='red')\n  }\n}\n\n\nAfter you created the matrices yix and muix you can use the following function to draw the lines for the quantiles.\n\n\nCode\nplot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='quantiles (y and mu)')\nquant_lines = function(x2, y_pred, col='blue'){\n  m = apply(y_pred, 2,quantile, probs=c(0.50))\n  lines(x2, m,col=col)\n  q05 = apply(y_pred, 2, quantile, probs=c(0.25))\n  q95 = apply(y_pred, 2, quantile, probs=c(0.75))\n  lines(x2, q05,col=col)\n  lines(x2, q95,col=col)  \n}\n\nquant_lines(xs,yix, col='red')\nquant_lines(xs,muix, col='blue')\n\n\n\n\n\n\n\n\nIt’s also possible to draw posterior predictive samples. One can use the generated quantities code block for that.\ndata{\n  int<lower=0> N;\n  vector[N] y;\n  vector[N] x;\n  //For the prediced distribution (new)\n  int<lower=0> N2;\n  vector[N2] x2;\n}\n\ngenerated quantities {\n  real Y_predict[N2]; \n  for (i in 1:N2){\n    Y_predict = normal_rng(a * x2 + b, sigma);\n  }\n}\n\n\nCode\n  x2 = -10:15\n  N2 = length(x2)\n  fit2 = rstan::stan(file = '~/Dropbox/__HTWG/DataAnalytics/_Current/lab/06_03_Bayes_3/Stan_Primer_model_pred.stan',\n                         data=list(N=N,x=x, y=y, N2=N2,x2=x2),iter=10000)\n\n\n\n\nCode\n  d2 = rstan::extract(fit2)\n  y_pred = d2$Y_predict\n  dim(y_pred)\n  plot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='quantiles (y and mu)')\n  quant_lines(x2,y_pred, col='red')"
  }
]