[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "da_website",
    "section": "",
    "text": "This is a collection of bits and pieces useful in connection with data analysis."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n\nCode\n1 + 1 + 1\n\n\n[1] 3"
  },
  {
    "objectID": "Stan_Primer_Full.html",
    "href": "Stan_Primer_Full.html",
    "title": "Stan primer",
    "section": "",
    "text": "MCMC with Stan / Simple diagnostics"
  },
  {
    "objectID": "Stan_Primer_Full.html#stan",
    "href": "Stan_Primer_Full.html#stan",
    "title": "Stan primer",
    "section": "Stan",
    "text": "Stan\n\nlibrary(rstan)\noptions(mc.cores = parallel::detectCores())\nrstan_options(javascript=FALSE) #Prevents freezes of RStudio (Jan 2023) \n\nm_rstan = stan_model(model_code = stan_code) #Compiling from string\nm_rstan = stan_model(file='mymodel.stan') #Compiling from file\ns_rstan = sampling(m_rstan, data=data) #Sampling from file\n\n#No MCMC just evaluating parameters\nsampling(model_1, data=dat, algorithm=\"Fixed_param\", chain=1, iter=1)"
  },
  {
    "objectID": "Stan_Primer_Full.html#cmdstan",
    "href": "Stan_Primer_Full.html#cmdstan",
    "title": "Stan primer",
    "section": "Cmdstan",
    "text": "Cmdstan\n\nlibrary(cmdstanr)\nm_rcmdstan &lt;- cmdstan_model(file_stan) #Compiling\ns_rcmdstan = m_rcmdstan$sample(data = data) #Sampling\ndf = s_rcmdstan$draws(format = \"df\") #Extracting Samples as data.frame\n\nPrinting the model in markdown\n{r, echo=lsg, eval=FALSE, code=readLines(“../world.stan”), collapse=TRUE}"
  },
  {
    "objectID": "Stan_Primer_Full.html#other-cheat-sheets",
    "href": "Stan_Primer_Full.html#other-cheat-sheets",
    "title": "Stan primer",
    "section": "Other Cheat Sheets",
    "text": "Other Cheat Sheets\n\nhttp://www.sumsar.net/files/posts/2017-bayesian-tutorial-exercises/stan_cheat_sheet2.12.pdf\nhttps://github.com/sieste/Stan_cheatsheet"
  },
  {
    "objectID": "Stan_Primer_Full.html#data-used",
    "href": "Stan_Primer_Full.html#data-used",
    "title": "Stan primer",
    "section": "Data used",
    "text": "Data used\nSome Data for linear regression\n\nN = 4\nx = c(-2.,-0.66666, 0.666, 2.)\ny = c(-6.25027354, -2.50213382, -6.07525495,  7.92081243)\ndata = list(N=N, x=x, y=y)"
  },
  {
    "objectID": "Stan_Primer_Full.html#getting-samples-from-the-posterior",
    "href": "Stan_Primer_Full.html#getting-samples-from-the-posterior",
    "title": "Stan primer",
    "section": "Getting samples from the posterior",
    "text": "Getting samples from the posterior\nThere are currently (2023) two interfaces to stan from R. RStan (https://mc-stan.org/users/interfaces/rstan) which is a bit slower and does not use the latest stan compiler and rcmdstan (https://mc-stan.org/cmdstanr/articles/cmdstanr.html).\n\nThe technical steps\nThere are 3 steps:\n\nDefining the model\nCompiling the model. In this step C code is generated.\nRunning the simulation / sampling from the posterior\nExtracting the samples from the posterior\n\n\n\nDefinition\nTo define a model, you can add a string or create a .stan file. Another option is to use a Stan markdown chunk and output.var=my_model to the name of the model. Code completion and highlighting is working for files and code chunks.\n\nstan_code = \"data{\n  int&lt;lower=0&gt; N;\n  vector[N] y;\n  vector[N] x;\n}\n\nparameters{\n  real a; //Instead of using e.g. half Gaussian\n  real b;\n  real&lt;lower=0&gt; sigma;\n}\n\nmodel{\n  //y ~ normal(mu, sigma);\n  y ~ normal(a * x + b, sigma);\n  a ~ normal(3, 10); \n  b ~ normal(0, 10); \n  sigma ~ normal(0,10);\n}\"\n\n\n\nCompiling\nCompiling works with:\n\nCompiling rstan stan_model(model_code = stan_code) or stan_model(file='mymodel.stan')\nCompiling cmdstan cmdstan_model(file_stan)\n\n\nCompiling with rstan\n\n  library(rstan)\n  m_rstan = stan_model(model_code = stan_code)\n\n\n\nCompiling with rcmdstan\nThere is no possibility to use a string for cmd_stan.\n\n  m_rcmdstan &lt;- cmdstan_model(stan_file='stan/simple_lr.stan')\n  m_rcmdstan$print() #Displays the used model\n\n\n\n\nSampling / running the chains\nFor rstan: sampling(m_rstan, data=data) For cmdstan: mod$sample(data = data_file, seed=123)\n\n  s_rcmdstan = m_rcmdstan$sample(data = data)\n\n\n  s_rstan = sampling(m_rstan)  \n\n\n\nDiagnostics of the chains\nThe package bayesplot can handle both interfaces\n\nTrace\n\n#traceplot(s_rstan, 'a')\n#bayesplot::mcmc_trace(s_rstan)\nbayesplot::mcmc_trace(s_rcmdstan$draws()) #similar result\ns_rstan\n# Rhat close to one and n_eff lager than half the number of draws; look fine\n\nKey Numbers\n\nRhat is something like the ratio of variation between the chains to withing the chains\nn_eff number of effective samples taking the autocorrelation into account (in cmd_stan the output is ess_bulk and ess_tail)\n\n\n\nShiny Stan\n\n  #Shiny Stan, quite overwhelming\n  library(shinystan)\n  launch_shinystan(s_rcmdstan)\n  \n  #If not working\n  #See https://discourse.mc-stan.org/t/will-launch-shinystan-work-soon-for-cmdstanr/17269\n  stanfit = rstan::read_stan_csv(s_rcmdstan$output_files())\n  launch_shinystan(stanfit)\n\n\n\n\nPosteriors (of the parameters)\nGetting the samples can be done as\n\nRstan extract(s_rstan)\ncmdstan s_rcmdstan$draws()\n\nAnother handy package is tidybayes which can handle the output of rstan and rcmdstan\n\nTidybayes\n\nlibrary(tidybayes)\nhead(spread_draws(s_rcmdstan, c(a,b))) #Non-tidy a and b in one row\n\n# A tibble: 6 × 5\n  .chain .iteration .draw     a      b\n   &lt;int&gt;      &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1      1          1     1  8.05 -1.91 \n2      1          2     2  4.19 -0.773\n3      1          3     3  3.91  0.584\n4      1          4     4  3.68  2.27 \n5      1          5     5  4.03  3.49 \n6      1          6     6  5.05 -0.631\n\nhead(gather_draws(s_rcmdstan, c(a,b))) #The ggplot like syntax\n\n# A tibble: 6 × 5\n# Groups:   .variable [1]\n  .chain .iteration .draw .variable .value\n   &lt;int&gt;      &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;dbl&gt;\n1      1          1     1 a           8.05\n2      1          2     2 a           4.19\n3      1          3     3 a           3.91\n4      1          4     4 a           3.68\n5      1          5     5 a           4.03\n6      1          6     6 a           5.05\n\n#spread_draws(model_weight_sex, a[sex]) for multilevel models\n\n\n\nCommand Stan Functions\nFor more see: https://mc-stan.org/cmdstanr/articles/cmdstanr.html\n\ndf &lt;- s_rcmdstan$draws(format = \"df\")\ndf %&gt;% select(-c(.chain, .iteration, .draw)) %&gt;% cor()\n\nWarning: Dropping 'draws_df' class as required metadata was removed.\n\n\n             lp__           a           b       sigma\nlp__   1.00000000 -0.05783566 -0.02147803 -0.67851552\na     -0.05783566  1.00000000 -0.03247364  0.03389968\nb     -0.02147803 -0.03247364  1.00000000  0.01933412\nsigma -0.67851552  0.03389968  0.01933412  1.00000000\n\n\n\n\nStan functions\n\n  #plot(samples)\n  #samples = extract(s_rstan)\n  stan_dens(s_rstan)\n\n\n\n  #Note that these are marginals!\n\n\n\n“Manually” visualize the posterior\nWe extract samples from the posterior via extract (in some installation the wrong extract function is taken in that case use rstan::extract to use the right one). Visualize the posterior distribution of \\(a\\) from the samples.\n\n# Extract samples\npost = rstan::extract(s_rstan)\nT = length(post$a)\nhist(post$a,100, freq=F)\nlines(density(post$a),col='red')  \n\n\n\n\n\n\nPairs plot\nUsing the pairs plot, correlations in the variables can be found.\n\nnp_cp = bayesplot::nuts_params(s_rstan)\nbayesplot::mcmc_pairs(s_rstan, np = np_cp,pars = c(\"a\",\"b\"))\n\n\n\n\n\n\n\nPosterior Predictive Plots\n\n\nTask: Use the samples to create the following posterior predictive plots\nSome background first: posterior predictive distribution: \\[\n  p(y|x, D) =  \\int p(y|x,\\theta) p(\\theta|D) \\; d\\theta\n\\] Instead of integration, we sample in two turns\n\n\\(\\theta_i \\sim p(\\theta|D)\\)\n\\(y_{ix} \\sim p(y|x,\\theta_i)\\) #We do this for many x in practice\n\n\nCreation of the posterior predictive samples by hand\nYou can either do this part, or use stan to create the posterior predictive samples \\(y_{ix}\\) from the samples \\(\\theta_i\\) by hand.\nTip: Create two matrices yix and muix from the posterior samples of \\(a,b,\\sigma\\) with dimension (rows = number of posterior samples and cols = number of x positions).\n\nxs = -10:15 # The x-range 17 values from -1 to 15\nM = length(xs) \nyix = matrix(nrow=T, ncol = M) #Matrix from samples (number of posterior draws vs number of xs)\nmuix = matrix(nrow=T, ncol = M) #Matrix from mu (number of posterior draws vs number of xs)\nfor (i in 1:T){ #Samples from the posterior\n  a = post$a[i] #Corresponds to samples from theta\n  b = post$b[i]\n  sigma = post$sigma[i]\n  for (j in 1:M){ #Different values of X\n    mu = a * xs[j] + b\n    muix[i,j] = a * xs[j] + b\n    yix[i,j] = rnorm(1, mu, sigma) # Single number drawn\n  }\n}\n\nif (FALSE){\n  plot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='mu=a*x+b')\n  for (i in 1:100){\n    lines(xs, muix[i,],lwd=0.25,col='blue')\n  }\n  \n  plot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='ys')\n  for (i in 1:100){\n    points(xs, yix[i,], pch='.',col='red')\n  }\n}\n\nAfter you created the matrices yix and muix you can use the following function to draw the lines for the quantiles.\n\nplot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='quantiles (y and mu)')\nquant_lines = function(x2, y_pred, col='blue'){\n  m = apply(y_pred, 2,quantile, probs=c(0.50))\n  lines(x2, m,col=col)\n  q05 = apply(y_pred, 2, quantile, probs=c(0.25))\n  q95 = apply(y_pred, 2, quantile, probs=c(0.75))\n  lines(x2, q05,col=col)\n  lines(x2, q95,col=col)  \n}\n\nquant_lines(xs,yix, col='red')\nquant_lines(xs,muix, col='blue')\n\n\n\n\n\n\nCreation of the posterior predictive samples with Stan\nIt’s also possible to draw posterior predictive samples. One can use the generated quantities code block for that.\ndata{\n  int&lt;lower=0&gt; N;\n  vector[N] y;\n  vector[N] x;\n  //For the prediced distribution (new)\n  int&lt;lower=0&gt; N2;\n  vector[N2] x2;\n}\n\ngenerated quantities {\n  real Y_predict[N2]; \n  for (i in 1:N2){\n    Y_predict = normal_rng(a * x2 + b, sigma);\n  }\n}\n\n  x2 = -10:15\n  N2 = length(x2)\n  fit2 = rstan::stan(file = '~/Dropbox/__HTWG/DataAnalytics/_Current/lab/06_03_Bayes_3/Stan_Primer_model_pred.stan',\n                         data=list(N=N,x=x, y=y, N2=N2,x2=x2),iter=10000)\n\n\n  d2 = rstan::extract(fit2)\n  y_pred = d2$Y_predict\n  dim(y_pred)\n  plot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='quantiles (y and mu)')\n  quant_lines(x2,y_pred, col='red')\n\n\n\n\nNotes on creating excercises\n\nInclusion of Stan code\nIn case of cmdrstan the Stan code should be in an extra file to make the workflow easier and reuse compiled models. In case of rstan the Stan code can be included in the Rmd file as:\n{r, echo=TRUE, eval=FALSE, code=readLines(“../world.stan”), collapse=TRUE, echo=TRUE}"
  },
  {
    "objectID": "Stan_Primer_Full.html#stan-1",
    "href": "Stan_Primer_Full.html#stan-1",
    "title": "Stan primer",
    "section": "Stan",
    "text": "Stan\n```{r rstan_minimal, eval=FALSE} library(rstan) options(mc.cores = parallel::detectCores()) rstan_options(javascript=FALSE) #Prevents freezes of RStudio (Jan 2023)\nm_rstan = stan_model(model_code = stan_code) #Compiling from string m_rstan = stan_model(file=‘mymodel.stan’) #Compiling from file s_rstan = sampling(m_rstan, data=data) #Sampling from file\n#No MCMC just evaluating parameters sampling(model_1, data=dat, algorithm=“Fixed_param”, chain=1, iter=1)\n\n## Cmdstan\n\n```{r cmdstan minimal, eval=FALSE}\nlibrary(cmdstanr)\nm_rcmdstan &lt;- cmdstan_model(file_stan) #Compiling\ns_rcmdstan = m_rcmdstan$sample(data = data) #Sampling\ndf = s_rcmdstan$draws(format = \"df\") #Extracting Samples as data.frame\n\nTidy Bayes\nWorks with rstan and cmdstanr\n{r tidy_bayes_minimal, eval=FALSE} library(tidybayes) spread_draws(s, c(a,b)) #Extracts a and b from s (stan or cmdstan samples) spread_draws(s, f[i])  #Extracts vector f and calls components i\n\n\nBayes plot\nWorks with rstan and cmdstanr {r tidy_bayes minimal, eval=FALSE}   s = s_rcmdstan$draws() #We need to call draws() 2023   bayesplot::mcmc_trace(s)\n\n\nRStudio\nSometimes R gets slow when dealing with stan. At least in my case\nrstan_options(javascript=FALSE)"
  },
  {
    "objectID": "Stan_Primer_Full.html#other-cheat-sheets-1",
    "href": "Stan_Primer_Full.html#other-cheat-sheets-1",
    "title": "Stan primer",
    "section": "Other Cheat Sheets",
    "text": "Other Cheat Sheets\n\nhttp://www.sumsar.net/files/posts/2017-bayesian-tutorial-exercises/stan_cheat_sheet2.12.pdf\nhttps://github.com/sieste/Stan_cheatsheet"
  },
  {
    "objectID": "Stan_Primer_Full.html#data-used-1",
    "href": "Stan_Primer_Full.html#data-used-1",
    "title": "Stan primer",
    "section": "Data used",
    "text": "Data used\nSome Data for linear regression\nquarto-executable-code-5450563D\nN = 4\nx = c(-2.,-0.66666, 0.666, 2.)\ny = c(-6.25027354, -2.50213382, -6.07525495,  7.92081243)\ndata = list(N=N, x=x, y=y)"
  },
  {
    "objectID": "Stan_Primer_Full.html#getting-samples-from-the-posterior-1",
    "href": "Stan_Primer_Full.html#getting-samples-from-the-posterior-1",
    "title": "Stan primer",
    "section": "Getting samples from the posterior",
    "text": "Getting samples from the posterior\nThere are currently (2023) two interfaces to stan from R. RStan (https://mc-stan.org/users/interfaces/rstan) which is a bit slower and does not use the latest stan compiler and rcmdstan (https://mc-stan.org/cmdstanr/articles/cmdstanr.html).\n\nThe technical steps\nThere are 3 steps:\n\nDefining the model\nCompiling the model. In this step C code is generated.\nRunning the simulation / sampling from the posterior\nExtracting the samples from the posterior\n\n\n\nDefinition\nTo define a model, you can add a string or create a .stan file. Another option is to use a Stan markdown chunk and output.var=my_model to the name of the model. Code completion and highlighting is working for files and code chunks.\n```{r, warning=FALSE,message=FALSE, eval=TRUE,echo=TRUE} stan_code = “data{ int&lt;lower=0&gt; N; vector[N] y; vector[N] x; }\nparameters{ real a; //Instead of using e.g. half Gaussian real b; real&lt;lower=0&gt; sigma; }\nmodel{ //y ~ normal(mu, sigma); y ~ normal(a * x + b, sigma); a ~ normal(3, 10); b ~ normal(0, 10); sigma ~ normal(0,10); }”\n\n### Compiling\n\nCompiling works with:\n\n-   Compiling rstan `stan_model(model_code = stan_code)` or `stan_model(file='mymodel.stan')`\n\n-   Compiling cmdstan `cmdstan_model(file_stan)`\n\n#### Compiling with rstan\n\n```{r results=\"hide\", cache=TRUE}\n  library(rstan)\n  m_rstan = stan_model(model_code = stan_code)\n\nCompiling with rcmdstan\nThere is no possibility to use a string for cmd_stan.\n{r results=\"hide\"}   m_rcmdstan &lt;- cmdstan_model(stan_file='stan/simple_lr.stan')   m_rcmdstan$print() #Displays the used model\n\n\n\nSampling / running the chains\nFor rstan: sampling(m_rstan, data=data) For cmdstan: mod$sample(data = data_file, seed=123)\n{r results=\"hide\"}   s_rcmdstan = m_rcmdstan$sample(data = data)\n{r results=\"hide\", cache=TRUE}   s_rstan = sampling(m_rstan)\n\n\nDiagnostics of the chains\nThe package bayesplot can handle both interfaces\n\nTrace\n{r trace, eval=FALSE} #traceplot(s_rstan, 'a') #bayesplot::mcmc_trace(s_rstan) bayesplot::mcmc_trace(s_rcmdstan$draws()) #similar result s_rstan # Rhat close to one and n_eff lager than half the number of draws; look fine\nKey Numbers\n\nRhat is something like the ratio of variation between the chains to withing the chains\nn_eff number of effective samples taking the autocorrelation into account (in cmd_stan the output is ess_bulk and ess_tail)\n\n\n\nShiny Stan\n```{r, eval=FALSE, echo=TRUE} #Shiny Stan, quite overwhelming library(shinystan) launch_shinystan(s_rcmdstan)\n#If not working #See https://discourse.mc-stan.org/t/will-launch-shinystan-work-soon-for-cmdstanr/17269 stanfit = rstan::read_stan_csv(s_rcmdstan$output_files()) launch_shinystan(stanfit)\n\n### Posteriors (of the parameters)\n\nGetting the samples can be done as\n\n-   Rstan `extract(s_rstan)`\n\n-   cmdstan `s_rcmdstan$draws()`\n\nAnother handy package is tidybayes which can handle the output of `rstan` and `rcmdstan`\n\n#### Tidybayes\nquarto-executable-code-5450563D\n\n```r\nlibrary(tidybayes)\nhead(spread_draws(s_rcmdstan, c(a,b))) #Non-tidy a and b in one row\nhead(gather_draws(s_rcmdstan, c(a,b))) #The ggplot like syntax\n#spread_draws(model_weight_sex, a[sex]) for multilevel models\n\n\nCommand Stan Functions\nFor more see: https://mc-stan.org/cmdstanr/articles/cmdstanr.html\nquarto-executable-code-5450563D\ndf &lt;- s_rcmdstan$draws(format = \"df\")\ndf %&gt;% select(-c(.chain, .iteration, .draw)) %&gt;% cor()\n\n\nStan functions\n{r, density, fig.height=3.5}   #plot(samples)   #samples = extract(s_rstan)   stan_dens(s_rstan)   #Note that these are marginals!\n\n\n“Manually” visualize the posterior\nWe extract samples from the posterior via extract (in some installation the wrong extract function is taken in that case use rstan::extract to use the right one). Visualize the posterior distribution of \\(a\\) from the samples.\n# Extract samples\npost = rstan::extract(s_rstan)\nT = length(post$a)\nhist(post$a,100, freq=F)\nlines(density(post$a),col='red')  \n\n\nPairs plot\nUsing the pairs plot, correlations in the variables can be found.\nquarto-executable-code-5450563D\nnp_cp = bayesplot::nuts_params(s_rstan)\nbayesplot::mcmc_pairs(s_rstan, np = np_cp,pars = c(\"a\",\"b\"))\n\n\n\nPosterior Predictive Plots\n\n\nTask: Use the samples to create the following posterior predictive plots\nSome background first: posterior predictive distribution: \\[\n  p(y|x, D) =  \\int p(y|x,\\theta) p(\\theta|D) \\; d\\theta\n\\] Instead of integration, we sample in two turns\n\n\\(\\theta_i \\sim p(\\theta|D)\\)\n\\(y_{ix} \\sim p(y|x,\\theta_i)\\) #We do this for many x in practice\n\n\nCreation of the posterior predictive samples by hand\nYou can either do this part, or use stan to create the posterior predictive samples \\(y_{ix}\\) from the samples \\(\\theta_i\\) by hand.\nTip: Create two matrices yix and muix from the posterior samples of \\(a,b,\\sigma\\) with dimension (rows = number of posterior samples and cols = number of x positions).\nquarto-executable-code-5450563D\nxs = -10:15 # The x-range 17 values from -1 to 15\nM = length(xs) \nyix = matrix(nrow=T, ncol = M) #Matrix from samples (number of posterior draws vs number of xs)\nmuix = matrix(nrow=T, ncol = M) #Matrix from mu (number of posterior draws vs number of xs)\nfor (i in 1:T){ #Samples from the posterior\n  a = post$a[i] #Corresponds to samples from theta\n  b = post$b[i]\n  sigma = post$sigma[i]\n  for (j in 1:M){ #Different values of X\n    mu = a * xs[j] + b\n    muix[i,j] = a * xs[j] + b\n    yix[i,j] = rnorm(1, mu, sigma) # Single number drawn\n  }\n}\n\nif (FALSE){\n  plot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='mu=a*x+b')\n  for (i in 1:100){\n    lines(xs, muix[i,],lwd=0.25,col='blue')\n  }\n  \n  plot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='ys')\n  for (i in 1:100){\n    points(xs, yix[i,], pch='.',col='red')\n  }\n}\nAfter you created the matrices yix and muix you can use the following function to draw the lines for the quantiles.\nplot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='quantiles (y and mu)')\nquant_lines = function(x2, y_pred, col='blue'){\n  m = apply(y_pred, 2,quantile, probs=c(0.50))\n  lines(x2, m,col=col)\n  q05 = apply(y_pred, 2, quantile, probs=c(0.25))\n  q95 = apply(y_pred, 2, quantile, probs=c(0.75))\n  lines(x2, q05,col=col)\n  lines(x2, q95,col=col)  \n}\n\nquant_lines(xs,yix, col='red')\nquant_lines(xs,muix, col='blue')\n\n\nCreation of the posterior predictive samples with Stan\nIt’s also possible to draw posterior predictive samples. One can use the generated quantities code block for that.\ndata{\n  int&lt;lower=0&gt; N;\n  vector[N] y;\n  vector[N] x;\n  //For the prediced distribution (new)\n  int&lt;lower=0&gt; N2;\n  vector[N2] x2;\n}\n\ngenerated quantities {\n  real Y_predict[N2]; \n  for (i in 1:N2){\n    Y_predict = normal_rng(a * x2 + b, sigma);\n  }\n}\n{r, eval=FALSE, results='hide'}   x2 = -10:15   N2 = length(x2)   fit2 = rstan::stan(file = '~/Dropbox/__HTWG/DataAnalytics/_Current/lab/06_03_Bayes_3/Stan_Primer_model_pred.stan',                          data=list(N=N,x=x, y=y, N2=N2,x2=x2),iter=10000)\n{r, eval=FALSE}   d2 = rstan::extract(fit2)   y_pred = d2$Y_predict   dim(y_pred)   plot(x, y, xlim=c(-10,15), ylim=c(-25,25), ylab='quantiles (y and mu)')   quant_lines(x2,y_pred, col='red')\n\n\n\nNotes on creating excercises\n\nInclusion of Stan code\nIn case of cmdrstan the Stan code should be in an extra file to make the workflow easier and reuse compiled models. In case of rstan the Stan code can be included in the Rmd file as:\n{verbatim, echo=TRUE, eval=FALSE}{r, echo=TRUE, eval=FALSE, code=readLines(“~/Documents/GitHub/da/lab/water_world/world.stan”), collapse=TRUE, echo=TRUE} #Stan Code\n\n``````````````````` :::"
  },
  {
    "objectID": "Stan_Primer_Full.html#tidy-bayes",
    "href": "Stan_Primer_Full.html#tidy-bayes",
    "title": "Stan primer",
    "section": "Tidy Bayes",
    "text": "Tidy Bayes\nWorks with rstan and cmdstanr\n\nlibrary(tidybayes)\nspread_draws(s, c(a,b)) #Extracts a and b from s (stan or cmdstan samples)\nspread_draws(s, f[i])  #Extracts vector f and calls components i"
  },
  {
    "objectID": "Stan_Primer_Full.html#bayes-plot",
    "href": "Stan_Primer_Full.html#bayes-plot",
    "title": "Stan primer",
    "section": "Bayes plot",
    "text": "Bayes plot\nWorks with rstan and cmdstanr\n\n  s = s_rcmdstan$draws() #We need to call draws() 2023\n  bayesplot::mcmc_trace(s)"
  },
  {
    "objectID": "Stan_Primer_Full.html#rstudio-bug-2023",
    "href": "Stan_Primer_Full.html#rstudio-bug-2023",
    "title": "Stan primer",
    "section": "RStudio bug 2023",
    "text": "RStudio bug 2023\nSometimes R gets slow when rendering with stan code. At least in my case\nrstan_options(javascript=FALSE)\nNot observed anymore (2024)"
  }
]